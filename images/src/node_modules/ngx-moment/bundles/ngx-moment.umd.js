(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),exports, require('@angular/core'), require('moment')) :
    typeof define === 'function' && define.amd ? define('ngx-moment', ['@angular/core','exports', '@angular/core', 'moment'], factory) :
    (global = global || self, factory(global.ng.core,global['ngx-moment'] = {}, global.ng.core, global.moment));
}(this, (function (ɵngcc0,exports, core, moment) { 'use strict';

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor = moment;
    var AddPipe = /** @class */ (function () {
        function AddPipe() {
        }
        AddPipe.prototype.transform = function (value, amount, unit) {
            if (typeof amount === 'undefined' ||
                (typeof amount === 'number' && typeof unit === 'undefined')) {
                throw new Error('AddPipe: missing required arguments');
            }
            return momentConstructor(value).add(amount, unit);
        };
AddPipe.ɵfac = function AddPipe_Factory(t) { return new (t || AddPipe)(); };
AddPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amAdd", type: AddPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AddPipe, [{
        type: core.Pipe,
        args: [{ name: 'amAdd' }]
    }], function () { return []; }, null); })();
        return AddPipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$1 = moment;
    var CalendarPipe = /** @class */ (function () {
        function CalendarPipe(cdRef, ngZone) {
            var _this = this;
            this.cdRef = cdRef;
            this.ngZone = ngZone;
            // using a single static timer for all instances of this pipe for performance reasons
            CalendarPipe.initTimer(ngZone);
            CalendarPipe.refs++;
            // values such as Today will need to be replaced with Yesterday after midnight,
            // so make sure we subscribe to an EventEmitter that we set up to emit at midnight
            this.midnightSub = CalendarPipe.midnight.subscribe(function () {
                _this.ngZone.run(function () { return _this.cdRef.markForCheck(); });
            });
        }
        CalendarPipe.prototype.transform = function (value) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var formats = null;
            var referenceTime = null;
            for (var i = 0, len = args.length; i < len; i++) {
                if (args[i] !== null) {
                    if (typeof args[i] === 'object' && !moment.isMoment(args[i])) {
                        formats = args[i];
                    }
                    else {
                        referenceTime = momentConstructor$1(args[i]);
                    }
                }
            }
            return momentConstructor$1(value).calendar(referenceTime, formats);
        };
        CalendarPipe.prototype.ngOnDestroy = function () {
            if (CalendarPipe.refs > 0) {
                CalendarPipe.refs--;
            }
            if (CalendarPipe.refs === 0) {
                CalendarPipe.removeTimer();
            }
            this.midnightSub.unsubscribe();
        };
        CalendarPipe.initTimer = function (ngZone) {
            // initialize the timer
            if (!CalendarPipe.midnight) {
                CalendarPipe.midnight = new core.EventEmitter();
                if (typeof window !== 'undefined') {
                    var timeToUpdate_1 = CalendarPipe._getMillisecondsUntilUpdate();
                    CalendarPipe.timer = ngZone.runOutsideAngular(function () {
                        return window.setTimeout(function () {
                            // emit the current date
                            CalendarPipe.midnight.emit(new Date());
                            // refresh the timer
                            CalendarPipe.removeTimer();
                            CalendarPipe.initTimer(ngZone);
                        }, timeToUpdate_1);
                    });
                }
            }
        };
        CalendarPipe.removeTimer = function () {
            if (CalendarPipe.timer) {
                window.clearTimeout(CalendarPipe.timer);
                CalendarPipe.timer = null;
                CalendarPipe.midnight = null;
            }
        };
        CalendarPipe._getMillisecondsUntilUpdate = function () {
            var now = momentConstructor$1();
            var tomorrow = momentConstructor$1().startOf('day').add(1, 'days');
            var timeToMidnight = tomorrow.valueOf() - now.valueOf();
            return timeToMidnight + 1000; // 1 second after midnight
        };
CalendarPipe.ɵfac = function CalendarPipe_Factory(t) { return new (t || CalendarPipe)(ɵngcc0.ɵɵinjectPipeChangeDetectorRef(), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
CalendarPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amCalendar", type: CalendarPipe, pure: false });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CalendarPipe, [{
        type: core.Pipe,
        args: [{ name: 'amCalendar', pure: false }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }]; }, null); })();
        return CalendarPipe;
    }());
    /**
     * Internal reference counter, so we can clean up when no instances are in use
     */
    CalendarPipe.refs = 0;
    CalendarPipe.timer = null;
    CalendarPipe.midnight = null;
    CalendarPipe.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef },
        { type: core.NgZone }
    ]; };

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$2 = moment;
    var DateFormatPipe = /** @class */ (function () {
        function DateFormatPipe() {
        }
        DateFormatPipe.prototype.transform = function (value) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!value) {
                return '';
            }
            return momentConstructor$2(value).format(args[0]);
        };
DateFormatPipe.ɵfac = function DateFormatPipe_Factory(t) { return new (t || DateFormatPipe)(); };
DateFormatPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amDateFormat", type: DateFormatPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateFormatPipe, [{
        type: core.Pipe,
        args: [{ name: 'amDateFormat' }]
    }], function () { return []; }, null); })();
        return DateFormatPipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$3 = moment;
    var DifferencePipe = /** @class */ (function () {
        function DifferencePipe() {
        }
        DifferencePipe.prototype.transform = function (value, otherValue, unit, precision) {
            var date = momentConstructor$3(value);
            var date2 = otherValue !== null ? momentConstructor$3(otherValue) : momentConstructor$3();
            return date.diff(date2, unit, precision);
        };
DifferencePipe.ɵfac = function DifferencePipe_Factory(t) { return new (t || DifferencePipe)(); };
DifferencePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amDifference", type: DifferencePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DifferencePipe, [{
        type: core.Pipe,
        args: [{ name: 'amDifference' }]
    }], function () { return []; }, null); })();
        return DifferencePipe;
    }());

    var NGX_MOMENT_OPTIONS = new core.InjectionToken('NGX_MOMENT_OPTIONS');

    var DurationPipe = /** @class */ (function () {
        function DurationPipe(momentOptions) {
            this.allowedUnits = ['ss', 's', 'm', 'h', 'd', 'M'];
            this._applyOptions(momentOptions);
        }
        DurationPipe.prototype.transform = function (value) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (typeof args === 'undefined' || args.length !== 1) {
                throw new Error('DurationPipe: missing required time unit argument');
            }
            return moment.duration(value, args[0]).humanize();
        };
        DurationPipe.prototype._applyOptions = function (momentOptions) {
            var _this = this;
            if (!momentOptions) {
                return;
            }
            if (!!momentOptions.relativeTimeThresholdOptions) {
                var units = Object.keys(momentOptions.relativeTimeThresholdOptions);
                var filteredUnits = units.filter(function (unit) { return _this.allowedUnits.indexOf(unit) !== -1; });
                filteredUnits.forEach(function (unit) {
                    moment.relativeTimeThreshold(unit, momentOptions.relativeTimeThresholdOptions[unit]);
                });
            }
        };
DurationPipe.ɵfac = function DurationPipe_Factory(t) { return new (t || DurationPipe)(ɵngcc0.ɵɵdirectiveInject(NGX_MOMENT_OPTIONS, 8)); };
DurationPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amDuration", type: DurationPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DurationPipe, [{
        type: core.Pipe,
        args: [{ name: 'amDuration' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [NGX_MOMENT_OPTIONS]
            }] }]; }, null); })();
        return DurationPipe;
    }());
    DurationPipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NGX_MOMENT_OPTIONS,] }] }
    ]; };

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var FromUnixPipe = /** @class */ (function () {
        function FromUnixPipe() {
        }
        FromUnixPipe.prototype.transform = function (value) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return typeof value === 'string' ? moment.unix(parseInt(value, 10)) : moment.unix(value);
        };
FromUnixPipe.ɵfac = function FromUnixPipe_Factory(t) { return new (t || FromUnixPipe)(); };
FromUnixPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amFromUnix", type: FromUnixPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FromUnixPipe, [{
        type: core.Pipe,
        args: [{ name: 'amFromUnix' }]
    }], function () { return []; }, null); })();
        return FromUnixPipe;
    }());

    var momentConstructor$4 = moment;
    var ParsePipe = /** @class */ (function () {
        function ParsePipe() {
        }
        ParsePipe.prototype.transform = function (value, formats) {
            return momentConstructor$4(value, formats);
        };
ParsePipe.ɵfac = function ParsePipe_Factory(t) { return new (t || ParsePipe)(); };
ParsePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amParse", type: ParsePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ParsePipe, [{
        type: core.Pipe,
        args: [{ name: 'amParse' }]
    }], function () { return []; }, null); })();
        return ParsePipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var FromUtcPipe = /** @class */ (function () {
        function FromUtcPipe() {
        }
        FromUtcPipe.prototype.transform = function (value, formats) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            return formats ? moment.utc(value, formats) : moment.utc(value);
        };
FromUtcPipe.ɵfac = function FromUtcPipe_Factory(t) { return new (t || FromUtcPipe)(); };
FromUtcPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amFromUtc", type: FromUtcPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FromUtcPipe, [{
        type: core.Pipe,
        args: [{ name: 'amFromUtc' }]
    }], function () { return []; }, null); })();
        return FromUtcPipe;
    }());

    var momentConstructor$5 = moment;
    var IsAfterPipe = /** @class */ (function () {
        function IsAfterPipe() {
        }
        IsAfterPipe.prototype.transform = function (value, otherValue, unit) {
            return momentConstructor$5(value).isAfter(momentConstructor$5(otherValue), unit);
        };
IsAfterPipe.ɵfac = function IsAfterPipe_Factory(t) { return new (t || IsAfterPipe)(); };
IsAfterPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amIsAfter", type: IsAfterPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IsAfterPipe, [{
        type: core.Pipe,
        args: [{
                name: 'amIsAfter'
            }]
    }], function () { return []; }, null); })();
        return IsAfterPipe;
    }());

    var momentConstructor$6 = moment;
    var IsBeforePipe = /** @class */ (function () {
        function IsBeforePipe() {
        }
        IsBeforePipe.prototype.transform = function (value, otherValue, unit) {
            return momentConstructor$6(value).isBefore(momentConstructor$6(otherValue), unit);
        };
IsBeforePipe.ɵfac = function IsBeforePipe_Factory(t) { return new (t || IsBeforePipe)(); };
IsBeforePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amIsBefore", type: IsBeforePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IsBeforePipe, [{
        type: core.Pipe,
        args: [{
                name: 'amIsBefore'
            }]
    }], function () { return []; }, null); })();
        return IsBeforePipe;
    }());

    var momentConstructor$7 = moment;
    var LocalTimePipe = /** @class */ (function () {
        function LocalTimePipe() {
        }
        LocalTimePipe.prototype.transform = function (value) {
            return momentConstructor$7(value).local();
        };
LocalTimePipe.ɵfac = function LocalTimePipe_Factory(t) { return new (t || LocalTimePipe)(); };
LocalTimePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amLocal", type: LocalTimePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalTimePipe, [{
        type: core.Pipe,
        args: [{ name: 'amLocal' }]
    }], function () { return []; }, null); })();
        return LocalTimePipe;
    }());

    // See https://github.com/ng-packagr/ng-packagr/issues/217 for why this is needed:
    var momentConstructor$8 = moment;
    var LocalePipe = /** @class */ (function () {
        function LocalePipe() {
        }
        LocalePipe.prototype.transform = function (value, locale) {
            return momentConstructor$8(value).locale(locale);
        };
LocalePipe.ɵfac = function LocalePipe_Factory(t) { return new (t || LocalePipe)(); };
LocalePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amLocale", type: LocalePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalePipe, [{
        type: core.Pipe,
        args: [{ name: 'amLocale' }]
    }], function () { return []; }, null); })();
        return LocalePipe;
    }());

    var ParseZonePipe = /** @class */ (function () {
        function ParseZonePipe() {
        }
        ParseZonePipe.prototype.transform = function (value) {
            return moment.parseZone(value);
        };
ParseZonePipe.ɵfac = function ParseZonePipe_Factory(t) { return new (t || ParseZonePipe)(); };
ParseZonePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amParseZone", type: ParseZonePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ParseZonePipe, [{
        type: core.Pipe,
        args: [{ name: 'amParseZone' }]
    }], function () { return []; }, null); })();
        return ParseZonePipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$9 = moment;
    var SubtractPipe = /** @class */ (function () {
        function SubtractPipe() {
        }
        SubtractPipe.prototype.transform = function (value, amount, unit) {
            if (typeof amount === 'undefined' ||
                (typeof amount === 'number' && typeof unit === 'undefined')) {
                throw new Error('SubtractPipe: missing required arguments');
            }
            return momentConstructor$9(value).subtract(amount, unit);
        };
SubtractPipe.ɵfac = function SubtractPipe_Factory(t) { return new (t || SubtractPipe)(); };
SubtractPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amSubtract", type: SubtractPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SubtractPipe, [{
        type: core.Pipe,
        args: [{ name: 'amSubtract' }]
    }], function () { return []; }, null); })();
        return SubtractPipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$a = moment;
    var TimeAgoPipe = /** @class */ (function () {
        function TimeAgoPipe(cdRef, ngZone) {
            this.cdRef = cdRef;
            this.ngZone = ngZone;
        }
        TimeAgoPipe.prototype.format = function (m) {
            return m.from(momentConstructor$a(), this.lastOmitSuffix);
        };
        TimeAgoPipe.prototype.transform = function (value, omitSuffix, formatFn) {
            if (this.hasChanged(value, omitSuffix)) {
                this.lastTime = this.getTime(value);
                this.lastValue = value;
                this.lastOmitSuffix = omitSuffix;
                this.lastLocale = this.getLocale(value);
                this.formatFn = formatFn || this.format.bind(this);
                this.removeTimer();
                this.createTimer();
                this.lastText = this.formatFn(momentConstructor$a(value));
            }
            else {
                this.createTimer();
            }
            return this.lastText;
        };
        TimeAgoPipe.prototype.ngOnDestroy = function () {
            this.removeTimer();
        };
        TimeAgoPipe.prototype.createTimer = function () {
            var _this = this;
            if (this.currentTimer) {
                return;
            }
            var momentInstance = momentConstructor$a(this.lastValue);
            var timeToUpdate = this.getSecondsUntilUpdate(momentInstance) * 1000;
            this.currentTimer = this.ngZone.runOutsideAngular(function () {
                if (typeof window !== 'undefined') {
                    return window.setTimeout(function () {
                        _this.lastText = _this.formatFn(momentConstructor$a(_this.lastValue));
                        _this.currentTimer = null;
                        _this.ngZone.run(function () { return _this.cdRef.markForCheck(); });
                    }, timeToUpdate);
                }
                else {
                    return null;
                }
            });
        };
        TimeAgoPipe.prototype.removeTimer = function () {
            if (this.currentTimer) {
                window.clearTimeout(this.currentTimer);
                this.currentTimer = null;
            }
        };
        TimeAgoPipe.prototype.getSecondsUntilUpdate = function (momentInstance) {
            var howOld = Math.abs(momentConstructor$a().diff(momentInstance, 'minute'));
            if (howOld < 1) {
                return 1;
            }
            else if (howOld < 60) {
                return 30;
            }
            else if (howOld < 180) {
                return 300;
            }
            else {
                return 3600;
            }
        };
        TimeAgoPipe.prototype.hasChanged = function (value, omitSuffix) {
            return (this.getTime(value) !== this.lastTime ||
                this.getLocale(value) !== this.lastLocale ||
                omitSuffix !== this.lastOmitSuffix);
        };
        TimeAgoPipe.prototype.getTime = function (value) {
            if (moment.isDate(value)) {
                return value.getTime();
            }
            else if (moment.isMoment(value)) {
                return value.valueOf();
            }
            else {
                return momentConstructor$a(value).valueOf();
            }
        };
        TimeAgoPipe.prototype.getLocale = function (value) {
            return moment.isMoment(value) ? value.locale() : moment.locale();
        };
TimeAgoPipe.ɵfac = function TimeAgoPipe_Factory(t) { return new (t || TimeAgoPipe)(ɵngcc0.ɵɵinjectPipeChangeDetectorRef(), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
TimeAgoPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amTimeAgo", type: TimeAgoPipe, pure: false });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimeAgoPipe, [{
        type: core.Pipe,
        args: [{ name: 'amTimeAgo', pure: false }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }]; }, null); })();
        return TimeAgoPipe;
    }());
    TimeAgoPipe.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef },
        { type: core.NgZone }
    ]; };

    var momentConstructor$b = moment;
    var UtcPipe = /** @class */ (function () {
        function UtcPipe() {
        }
        UtcPipe.prototype.transform = function (value) {
            return momentConstructor$b(value).utc();
        };
UtcPipe.ɵfac = function UtcPipe_Factory(t) { return new (t || UtcPipe)(); };
UtcPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "amUtc", type: UtcPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UtcPipe, [{
        type: core.Pipe,
        args: [{ name: 'amUtc' }]
    }], function () { return []; }, null); })();
        return UtcPipe;
    }());

    var ANGULAR_MOMENT_PIPES = [
        AddPipe,
        CalendarPipe,
        DateFormatPipe,
        DifferencePipe,
        DurationPipe,
        FromUnixPipe,
        ParsePipe,
        SubtractPipe,
        TimeAgoPipe,
        UtcPipe,
        FromUtcPipe,
        LocalTimePipe,
        LocalePipe,
        ParseZonePipe,
        IsBeforePipe,
        IsAfterPipe,
    ];
    var MomentModule = /** @class */ (function () {
        function MomentModule() {
        }
        MomentModule.forRoot = function (options) {
            return {
                ngModule: MomentModule,
                providers: [
                    {
                        provide: NGX_MOMENT_OPTIONS,
                        useValue: Object.assign({}, options),
                    },
                ],
            };
        };
MomentModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MomentModule });
MomentModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MomentModule_Factory(t) { return new (t || MomentModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MomentModule, { declarations: [AddPipe, CalendarPipe, DateFormatPipe, DifferencePipe, DurationPipe, FromUnixPipe, ParsePipe, SubtractPipe, TimeAgoPipe, UtcPipe, FromUtcPipe, LocalTimePipe, LocalePipe, ParseZonePipe, IsBeforePipe, IsAfterPipe], exports: [AddPipe, CalendarPipe, DateFormatPipe, DifferencePipe, DurationPipe, FromUnixPipe, ParsePipe, SubtractPipe, TimeAgoPipe, UtcPipe, FromUtcPipe, LocalTimePipe, LocalePipe, ParseZonePipe, IsBeforePipe, IsAfterPipe] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MomentModule, [{
        type: core.NgModule,
        args: [{
                declarations: ANGULAR_MOMENT_PIPES,
                exports: ANGULAR_MOMENT_PIPES
            }]
    }], function () { return []; }, null); })();
        return MomentModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AddPipe = AddPipe;
    exports.CalendarPipe = CalendarPipe;
    exports.DateFormatPipe = DateFormatPipe;
    exports.DifferencePipe = DifferencePipe;
    exports.DurationPipe = DurationPipe;
    exports.FromUnixPipe = FromUnixPipe;
    exports.FromUtcPipe = FromUtcPipe;
    exports.IsAfterPipe = IsAfterPipe;
    exports.IsBeforePipe = IsBeforePipe;
    exports.LocalTimePipe = LocalTimePipe;
    exports.LocalePipe = LocalePipe;
    exports.MomentModule = MomentModule;
    exports.NGX_MOMENT_OPTIONS = NGX_MOMENT_OPTIONS;
    exports.ParsePipe = ParsePipe;
    exports.ParseZonePipe = ParseZonePipe;
    exports.SubtractPipe = SubtractPipe;
    exports.TimeAgoPipe = TimeAgoPipe;
    exports.UtcPipe = UtcPipe;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-moment.umd.js.map