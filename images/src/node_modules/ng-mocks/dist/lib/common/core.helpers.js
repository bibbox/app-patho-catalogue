"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendClass = exports.extractDependency = exports.mapEntries = exports.mapValues = exports.mapKeys = exports.flatten = exports.getInjection = exports.getTestBedInjection = void 0;
var testing_1 = require("@angular/core/testing");
var core_reflect_1 = require("./core.reflect");
exports.getTestBedInjection = function (token) {
    var testBed = testing_1.getTestBed();
    try {
        /* istanbul ignore next */
        return testBed.inject ? testBed.inject(token) : testBed.get(token);
    }
    catch (e) {
        return undefined;
    }
};
exports.getInjection = function (token) {
    var testBed = testing_1.getTestBed();
    /* istanbul ignore next */
    return testBed.inject ? testBed.inject(token) : testBed.get(token);
};
exports.flatten = function (values, result) {
    if (result === void 0) { result = []; }
    if (Array.isArray(values)) {
        values.forEach(function (value) { return exports.flatten(value, result); });
    }
    else {
        result.push(values);
    }
    return result;
};
exports.mapKeys = function (set) {
    var result = [];
    set.forEach(function (_, value) { return result.push(value); });
    return result;
};
exports.mapValues = function (set) {
    var result = [];
    set.forEach(function (value) { return result.push(value); });
    return result;
};
exports.mapEntries = function (set) {
    var result = [];
    set.forEach(function (value, key) { return result.push([key, value]); });
    return result;
};
// Accepts an array of dependencies from providers, skips injections flags,
// and adds the providers to the set.
exports.extractDependency = function (deps, set) {
    var e_1, _a, e_2, _b;
    if (!set) {
        return;
    }
    try {
        for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {
            var dep = deps_1_1.value;
            if (!Array.isArray(dep)) {
                set.add(dep);
                continue;
            }
            try {
                for (var dep_1 = (e_2 = void 0, __values(dep)), dep_1_1 = dep_1.next(); !dep_1_1.done; dep_1_1 = dep_1.next()) {
                    var flag = dep_1_1.value;
                    if (flag && typeof flag === 'object' && flag.ngMetadataName === 'Optional') {
                        continue;
                    }
                    if (flag && typeof flag === 'object' && flag.ngMetadataName === 'SkipSelf') {
                        continue;
                    }
                    if (flag && typeof flag === 'object' && flag.ngMetadataName === 'Self') {
                        continue;
                    }
                    set.add(flag);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (dep_1_1 && !dep_1_1.done && (_b = dep_1.return)) _b.call(dep_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
};
exports.extendClass = function (base) {
    var child;
    var parent = base;
    // first we try to eval es2015 style and if it fails to use es5 transpilation in the catch block.
    window.ngMocksParent = parent;
    /* istanbul ignore next */
    try {
        // tslint:disable-next-line:no-eval
        eval("\n        class child extends window.ngMocksParent {\n        }\n        window.ngMocksResult = child\n      ");
        child = window.ngMocksResult;
    }
    catch (e) {
        var ClassEs5 = /** @class */ (function (_super) {
            __extends(ClassEs5, _super);
            function ClassEs5() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return ClassEs5;
        }(parent));
        child = ClassEs5;
    }
    window.ngMocksParent = undefined;
    // the next step is to respect constructor parameters as the parent class.
    child.parameters = core_reflect_1.jitReflector.parameters(parent);
    return child;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29yZS5oZWxwZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2NvbW1vbi9jb3JlLmhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsaURBQW1EO0FBRW5ELCtDQUE4QztBQUdqQyxRQUFBLG1CQUFtQixHQUFHLFVBQUksS0FBa0M7SUFDdkUsSUFBTSxPQUFPLEdBQVEsb0JBQVUsRUFBRSxDQUFDO0lBQ2xDLElBQUk7UUFDRiwwQkFBMEI7UUFDMUIsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3BFO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUMsQ0FBQztBQUVXLFFBQUEsWUFBWSxHQUFHLFVBQUksS0FBa0M7SUFDaEUsSUFBTSxPQUFPLEdBQVEsb0JBQVUsRUFBRSxDQUFDO0lBQ2xDLDBCQUEwQjtJQUMxQixPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckUsQ0FBQyxDQUFDO0FBRVcsUUFBQSxPQUFPLEdBQUcsVUFBSSxNQUFlLEVBQUUsTUFBZ0I7SUFBaEIsdUJBQUEsRUFBQSxXQUFnQjtJQUMxRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDekIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEtBQWMsSUFBSyxPQUFBLGVBQU8sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLEVBQXRCLENBQXNCLENBQUMsQ0FBQztLQUM1RDtTQUFNO1FB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USxDQUFDO0tBQ2xCO0lBQ0EsTUFBYyxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7SUFFMUMsMEVBQTBFO0lBQzFFLEtBQUssQ0FBQyxVQUFVLEdBQUcsMkJBQVksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFbkQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZ2V0VGVzdEJlZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvdGVzdGluZyc7XG5cbmltcG9ydCB7IGppdFJlZmxlY3RvciB9IGZyb20gJy4vY29yZS5yZWZsZWN0JztcbmltcG9ydCB7IFR5cGUgfSBmcm9tICcuL2NvcmUudHlwZXMnO1xuXG5leHBvcnQgY29uc3QgZ2V0VGVzdEJlZEluamVjdGlvbiA9IDxJPih0b2tlbjogVHlwZTxJPiB8IEluamVjdGlvblRva2VuPEk+KTogSSB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IHRlc3RCZWQ6IGFueSA9IGdldFRlc3RCZWQoKTtcbiAgdHJ5IHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0ZXN0QmVkLmluamVjdCA/IHRlc3RCZWQuaW5qZWN0KHRva2VuKSA6IHRlc3RCZWQuZ2V0KHRva2VuKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJbmplY3Rpb24gPSA8ST4odG9rZW46IFR5cGU8ST4gfCBJbmplY3Rpb25Ub2tlbjxJPik6IEkgPT4ge1xuICBjb25zdCB0ZXN0QmVkOiBhbnkgPSBnZXRUZXN0QmVkKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiB0ZXN0QmVkLmluamVjdCA/IHRlc3RCZWQuaW5qZWN0KHRva2VuKSA6IHRlc3RCZWQuZ2V0KHRva2VuKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gPFQ+KHZhbHVlczogVCB8IFRbXSwgcmVzdWx0OiBUW10gPSBbXSk6IFRbXSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWU6IFQgfCBUW10pID0+IGZsYXR0ZW4odmFsdWUsIHJlc3VsdCkpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wdXNoKHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXBLZXlzID0gPFQ+KHNldDogTWFwPFQsIGFueT4pOiBUW10gPT4ge1xuICBjb25zdCByZXN1bHQ6IFRbXSA9IFtdO1xuICBzZXQuZm9yRWFjaCgoXywgdmFsdWU6IFQpID0+IHJlc3VsdC5wdXNoKHZhbHVlKSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgbWFwVmFsdWVzID0gPFQ+KHNldDogeyBmb3JFYWNoKGExOiAodmFsdWU6IFQpID0+IHZvaWQpOiB2b2lkIH0pOiBUW10gPT4ge1xuICBjb25zdCByZXN1bHQ6IFRbXSA9IFtdO1xuICBzZXQuZm9yRWFjaCgodmFsdWU6IFQpID0+IHJlc3VsdC5wdXNoKHZhbHVlKSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgbWFwRW50cmllcyA9IDxLLCBUPihzZXQ6IE1hcDxLLCBUPik6IEFycmF5PFtLLCBUXT4gPT4ge1xuICBjb25zdCByZXN1bHQ6IEFycmF5PFtLLCBUXT4gPSBbXTtcbiAgc2V0LmZvckVhY2goKHZhbHVlOiBULCBrZXk6IEspID0+IHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSkpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gQWNjZXB0cyBhbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgZnJvbSBwcm92aWRlcnMsIHNraXBzIGluamVjdGlvbnMgZmxhZ3MsXG4vLyBhbmQgYWRkcyB0aGUgcHJvdmlkZXJzIHRvIHRoZSBzZXQuXG5leHBvcnQgY29uc3QgZXh0cmFjdERlcGVuZGVuY3kgPSAoZGVwczogYW55W10sIHNldD86IFNldDxhbnk+KTogdm9pZCA9PiB7XG4gIGlmICghc2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVwKSkge1xuICAgICAgc2V0LmFkZChkZXApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmxhZyBvZiBkZXApIHtcbiAgICAgIGlmIChmbGFnICYmIHR5cGVvZiBmbGFnID09PSAnb2JqZWN0JyAmJiBmbGFnLm5nTWV0YWRhdGFOYW1lID09PSAnT3B0aW9uYWwnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZsYWcgJiYgdHlwZW9mIGZsYWcgPT09ICdvYmplY3QnICYmIGZsYWcubmdNZXRhZGF0YU5hbWUgPT09ICdTa2lwU2VsZicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZyAmJiB0eXBlb2YgZmxhZyA9PT0gJ29iamVjdCcgJiYgZmxhZy5uZ01ldGFkYXRhTmFtZSA9PT0gJ1NlbGYnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc2V0LmFkZChmbGFnKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBleHRlbmRDbGFzcyA9IDxJIGV4dGVuZHMgb2JqZWN0PihiYXNlOiBUeXBlPEk+KTogVHlwZTxJPiA9PiB7XG4gIGxldCBjaGlsZDogYW55O1xuICBjb25zdCBwYXJlbnQ6IGFueSA9IGJhc2U7XG5cbiAgLy8gZmlyc3Qgd2UgdHJ5IHRvIGV2YWwgZXMyMDE1IHN0eWxlIGFuZCBpZiBpdCBmYWlscyB0byB1c2UgZXM1IHRyYW5zcGlsYXRpb24gaW4gdGhlIGNhdGNoIGJsb2NrLlxuICAod2luZG93IGFzIGFueSkubmdNb2Nrc1BhcmVudCA9IHBhcmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdHJ5IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZXZhbFxuICAgIGV2YWwoYFxuICAgICAgICBjbGFzcyBjaGlsZCBleHRlbmRzIHdpbmRvdy5uZ01vY2tzUGFyZW50IHtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cubmdNb2Nrc1Jlc3VsdCA9IGNoaWxkXG4gICAgICBgKTtcbiAgICBjaGlsZCA9ICh3aW5kb3cgYXMgYW55KS5uZ01vY2tzUmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2xhc3MgQ2xhc3NFczUgZXh0ZW5kcyBwYXJlbnQge31cblxuICAgIGNoaWxkID0gQ2xhc3NFczU7XG4gIH1cbiAgKHdpbmRvdyBhcyBhbnkpLm5nTW9ja3NQYXJlbnQgPSB1bmRlZmluZWQ7XG5cbiAgLy8gdGhlIG5leHQgc3RlcCBpcyB0byByZXNwZWN0IGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgYXMgdGhlIHBhcmVudCBjbGFzcy5cbiAgY2hpbGQucGFyYW1ldGVycyA9IGppdFJlZmxlY3Rvci5wYXJhbWV0ZXJzKHBhcmVudCk7XG5cbiAgcmV0dXJuIGNoaWxkO1xufTtcbiJdfQ==