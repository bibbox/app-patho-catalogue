"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockNgDef = exports.MockModule = void 0;
var core_1 = require("@angular/core");
var testing_1 = require("@angular/core/testing");
var core_config_1 = require("../common/core.config");
var core_helpers_1 = require("../common/core.helpers");
var core_reflect_1 = require("../common/core.reflect");
var func_get_mocked_ng_def_of_1 = require("../common/func.get-mocked-ng-def-of");
var func_is_ng_def_1 = require("../common/func.is-ng-def");
var func_is_ng_module_def_with_providers_1 = require("../common/func.is-ng-module-def-with-providers");
var mock_1 = require("../common/mock");
var mock_of_1 = require("../common/mock-of");
var ng_mocks_universe_1 = require("../common/ng-mocks-universe");
var mock_component_1 = require("../mock-component/mock-component");
var mock_directive_1 = require("../mock-directive/mock-directive");
var mock_pipe_1 = require("../mock-pipe/mock-pipe");
var helper_1 = require("../mock-service/helper");
function MockModule(module) {
    var _a, _b;
    var ngModule;
    var ngModuleProviders;
    var mockModule;
    var mockModuleProviders;
    var mockModuleDef;
    var toggleSkipMockFlag = false;
    if (func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders(module)) {
        ngModule = module.ngModule;
        if (module.providers) {
            ngModuleProviders = module.providers;
        }
    }
    else {
        ngModule = module;
    }
    // We are inside of an 'it'.
    // It's fine to to return a mock copy or to throw an exception if it wasn't replaced with its mock copy in TestBed.
    if (!ngModuleProviders && testing_1.getTestBed()._instantiated) {
        try {
            return func_get_mocked_ng_def_of_1.getMockedNgDefOf(ngModule, 'm');
        }
        catch (error) {
            // looks like an in-test mock.
        }
    }
    // Every module should be replaced with its mock copy only once to avoid errors like:
    // Failed: Type ...Component is part of the declarations of 2 modules: ...Module and ...Module...
    if (ng_mocks_universe_1.default.flags.has('cacheModule') && ng_mocks_universe_1.default.cacheDeclarations.has(ngModule)) {
        mockModule = ng_mocks_universe_1.default.cacheDeclarations.get(ngModule);
    }
    var resolution = (_a = ng_mocks_universe_1.default.config
        .get('resolution')) === null || _a === void 0 ? void 0 : _a.get(ngModule);
    if (resolution === 'mock' && ng_mocks_universe_1.default.flags.has('skipMock')) {
        toggleSkipMockFlag = true;
        ng_mocks_universe_1.default.flags.delete('skipMock');
    }
    if (resolution === 'keep' && !ng_mocks_universe_1.default.flags.has('skipMock')) {
        toggleSkipMockFlag = true;
        ng_mocks_universe_1.default.flags.add('skipMock');
    }
    if (resolution === 'replace' && !ng_mocks_universe_1.default.flags.has('skipMock')) {
        toggleSkipMockFlag = true;
        ng_mocks_universe_1.default.flags.add('skipMock');
    }
    if (core_config_1.default.neverMockModule.indexOf(ngModule) !== -1 && !ng_mocks_universe_1.default.flags.has('skipMock')) {
        toggleSkipMockFlag = true;
        ng_mocks_universe_1.default.flags.add('skipMock');
    }
    // Now we check if we need to keep the original module or to replace it with some other.
    if (!mockModule && ng_mocks_universe_1.default.builtDeclarations.has(ngModule)) {
        var instance = ng_mocks_universe_1.default.builtDeclarations.get(ngModule);
        if (func_is_ng_def_1.isNgDef(instance, 'm') && instance !== ngModule) {
            mockModule = instance;
        }
    }
    if (!mockModule) {
        var meta = void 0;
        try {
            meta = core_reflect_1.ngModuleResolver.resolve(ngModule);
        }
        catch (e) {
            /* istanbul ignore next */
            throw new Error('ng-mocks is not in JIT mode and cannot resolve declarations');
        }
        var _c = __read(MockNgDef(meta, ngModule), 2), changed = _c[0], ngModuleDef = _c[1];
        if (changed) {
            mockModuleDef = ngModuleDef;
        }
    }
    if (mockModuleDef) {
        var parent_1 = ng_mocks_universe_1.default.flags.has('skipMock') ? ngModule : mock_1.Mock;
        mockModule = core_helpers_1.extendClass(parent_1);
        // the last thing is to apply decorators.
        core_1.NgModule(mockModuleDef)(mockModule);
        mock_of_1.MockOf(ngModule)(mockModule);
    }
    if (!mockModule) {
        mockModule = ngModule;
    }
    // We should always cache the result, in global scope it always will be a mock.
    // In MockBuilder scope it will be reset later anyway.
    /* istanbul ignore else */
    if (ng_mocks_universe_1.default.flags.has('cacheModule')) {
        ng_mocks_universe_1.default.cacheDeclarations.set(ngModule, mockModule);
    }
    if (ng_mocks_universe_1.default.flags.has('skipMock')) {
        (_b = ng_mocks_universe_1.default.config.get('depsSkip')) === null || _b === void 0 ? void 0 : _b.add(mockModule);
    }
    if (ngModuleProviders) {
        var _d = __read(MockNgDef({ providers: ngModuleProviders }), 2), changed = _d[0], ngModuleDef = _d[1];
        mockModuleProviders = changed ? ngModuleDef.providers : ngModuleProviders;
    }
    if (toggleSkipMockFlag && ng_mocks_universe_1.default.flags.has('skipMock')) {
        ng_mocks_universe_1.default.flags.delete('skipMock');
    }
    else if (toggleSkipMockFlag && !ng_mocks_universe_1.default.flags.has('skipMock')) {
        ng_mocks_universe_1.default.flags.add('skipMock');
    }
    return mockModule === ngModule && mockModuleProviders === ngModuleProviders
        ? module
        : func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders(module)
            ? __assign({ ngModule: mockModule }, (mockModuleProviders ? { providers: mockModuleProviders } : {})) : mockModule;
}
exports.MockModule = MockModule;
/**
 * Can be changed at any time.
 *
 * @internal
 */
function MockNgDef(ngModuleDef, ngModule) {
    var e_1, _a;
    var changed = !ng_mocks_universe_1.default.flags.has('skipMock');
    var mockModuleDef = {};
    var _b = ngModuleDef.bootstrap, bootstrap = _b === void 0 ? [] : _b, _c = ngModuleDef.declarations, declarations = _c === void 0 ? [] : _c, _d = ngModuleDef.entryComponents, entryComponents = _d === void 0 ? [] : _d, _e = ngModuleDef.exports, exports = _e === void 0 ? [] : _e, _f = ngModuleDef.imports, imports = _f === void 0 ? [] : _f, _g = ngModuleDef.providers, providers = _g === void 0 ? [] : _g;
    var resolutions = new Map();
    // resolveProvider is a special case because of the def structure.
    var resolveProvider = function (def) {
        return helper_1.default.resolveProvider(def, resolutions, function (flag) {
            changed = changed || flag;
        });
    };
    var resolve = function (def) {
        var _a;
        var mockDef;
        if (resolutions.has(def)) {
            return resolutions.get(def);
        }
        // skipping excluded things
        if (ng_mocks_universe_1.default.builtDeclarations.has(def) && ng_mocks_universe_1.default.builtDeclarations.get(def) === null) {
            changed = changed || true;
            resolutions.set(def, undefined);
            return;
        }
        ng_mocks_universe_1.default.touches.add(func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders(def) ? def.ngModule : def);
        // First we mock modules.
        if (func_is_ng_def_1.isNgDef(def, 'm')) {
            mockDef = MockModule(def);
        }
        if (!mockDef && func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders(def)) {
            mockDef = MockModule(def);
            resolutions.set(def.ngModule, mockDef.ngModule);
        }
        // Then we check decisions whether we should keep or replace a def.
        if (!mockDef && ng_mocks_universe_1.default.builtDeclarations.has(def)) {
            mockDef = ng_mocks_universe_1.default.builtDeclarations.get(def);
        }
        // And then we mock what we have if it wasn't blocked by the skipMock.
        if (!mockDef && ng_mocks_universe_1.default.flags.has('skipMock')) {
            mockDef = def;
        }
        if (!mockDef && func_is_ng_def_1.isNgDef(def, 'c')) {
            mockDef = mock_component_1.MockComponent(def);
        }
        if (!mockDef && func_is_ng_def_1.isNgDef(def, 'd')) {
            mockDef = mock_directive_1.MockDirective(def);
        }
        if (!mockDef && func_is_ng_def_1.isNgDef(def, 'p')) {
            mockDef = mock_pipe_1.MockPipe(def);
        }
        if (ng_mocks_universe_1.default.flags.has('skipMock')) {
            (_a = ng_mocks_universe_1.default.config.get('depsSkip')) === null || _a === void 0 ? void 0 : _a.add(mockDef);
        }
        resolutions.set(def, mockDef);
        changed = changed || mockDef !== def;
        return mockDef;
    };
    if (declarations && declarations.length) {
        mockModuleDef.declarations = core_helpers_1.flatten(declarations)
            .map(resolve)
            .filter(function (declaration) { return declaration; });
    }
    if (entryComponents && entryComponents.length) {
        mockModuleDef.entryComponents = core_helpers_1.flatten(entryComponents)
            .map(resolve)
            .filter(function (declaration) { return declaration; });
    }
    if (bootstrap && bootstrap.length) {
        mockModuleDef.bootstrap = core_helpers_1.flatten(bootstrap)
            .map(resolve)
            .filter(function (declaration) { return declaration; });
    }
    if (providers && providers.length) {
        mockModuleDef.providers = core_helpers_1.flatten(providers)
            .map(resolveProvider)
            .filter(function (declaration) { return declaration; });
    }
    // mock imports should be the latest step before exports to ensure
    // that everything has been replaced with its mock copy already
    if (imports && imports.length) {
        mockModuleDef.imports = core_helpers_1.flatten(imports)
            .map(resolve)
            .filter(function (declaration) { return declaration; });
    }
    // Default exports.
    if (exports && exports.length) {
        mockModuleDef.exports = core_helpers_1.flatten(exports)
            .map(resolve)
            .filter(function (declaration) { return declaration; });
    }
    // if we are in the skipMock mode we need to export only the default exports.
    // if we are in the correctModuleExports mode we need to export only default exports.
    var correctExports = ng_mocks_universe_1.default.flags.has('skipMock') || ng_mocks_universe_1.default.flags.has('correctModuleExports');
    try {
        // When we mock a module, only exported declarations are accessible inside of a test.
        // Because of that we have to export whatever a module imports or declares.
        // Unfortunately, in this case tests won't fail when a module has missed exports.
        // MockBuilder doesn't have have this issue.
        for (var _h = __values(core_helpers_1.flatten([imports, declarations])), _j = _h.next(); !_j.done; _j = _h.next()) {
            var def = _j.value;
            var moduleConfig = ng_mocks_universe_1.default.config.get(ngModule) || {};
            var instance = func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders(def) ? def.ngModule : def;
            var mockDef = resolve(instance);
            if (!mockDef) {
                continue;
            }
            // If we export a declaration, then we have to export its module too.
            var config = ng_mocks_universe_1.default.config.get(instance) || {};
            if (config.export && ngModule) {
                if (!moduleConfig.export) {
                    ng_mocks_universe_1.default.config.set(ngModule, __assign(__assign({}, moduleConfig), { export: true }));
                }
            }
            if (correctExports && !config.export && !moduleConfig.exportAll) {
                continue;
            }
            if (mockModuleDef.exports && mockModuleDef.exports.indexOf(mockDef) !== -1) {
                continue;
            }
            changed = true;
            mockModuleDef.exports = mockModuleDef.exports || [];
            mockModuleDef.exports.push(mockDef);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_j && !_j.done && (_a = _h.return)) _a.call(_h);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return [changed, mockModuleDef];
}
exports.MockNgDef = MockNgDef;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1tb2R1bGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvbW9jay1tb2R1bGUvbW9jay1tb2R1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxzQ0FBbUQ7QUFDbkQsaURBQW1EO0FBRW5ELHFEQUE2QztBQUM3Qyx1REFBOEQ7QUFDOUQsdURBQTBEO0FBRTFELGlGQUF1RTtBQUN2RSwyREFBbUQ7QUFDbkQsdUdBQW1IO0FBQ25ILHVDQUFzQztBQUN0Qyw2Q0FBMkM7QUFDM0MsaUVBQTBEO0FBQzFELG1FQUFpRTtBQUNqRSxtRUFBaUU7QUFDakUsb0RBQWtEO0FBQ2xELGlEQUF1RDtBQVd2RCxTQUFnQixVQUFVLENBQUMsTUFBVzs7SUFDcEMsSUFBSSxRQUFtQixDQUFDO0lBQ3hCLElBQUksaUJBQXlDLENBQUM7SUFDOUMsSUFBSSxVQUF1QyxDQUFDO0lBQzVDLElBQUksbUJBQTZDLENBQUM7SUFDbEQsSUFBSSxhQUFtQyxDQUFDO0lBQ3hDLElBQUksa0JBQWtCLEdBQUcsS0FBSyxDQUFDO0lBRS9CLElBQUksaUVBQTBCLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDdEMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFDM0IsSUFBSSxNQUFNLENBQUMsU0FBUyxFQUFFO1lBQ3BCLGlCQUFpQixHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7U0FDdEM7S0FDRjtTQUFNO1FBQ0wsUUFBUSxHQUFHLE1BQU0sQ0FBQztLQUNuQjtJQUVELDRCQUE0QjtJQUM1QixtSEFBbUg7SUFDbkgsSUFBSSxDQUFDLGlCQUFpQixJQUFLLG9CQUFVLEVBQVUsQ0FBQyxhQUFhLEVBQUU7UUFDN0QsSUFBSTtZQUNGLE9BQU8sNENBQWdCLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQ3hDO1FBQUMsT0FBTyxLQUFLLEVBQUU7WUFDZCw4QkFB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UUFBUSx3QkFDOUIsWUFBWSxLQUNmLE1BQU0sRUFBRSxJQUFJLElBQ1osQ0FBQztpQkFDSjthQUNGO1lBRUQsSUFBSSxjQUFjLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRTtnQkFDL0QsU0FBUzthQUNWO1lBQ0QsSUFBSSxhQUFhLENBQUMsT0FBTyxJQUFJLGFBQWEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUMxRSxTQUFTO2FBQ1Y7WUFFRCxPQUFPLEdBQUcsSUFBSSxDQUFDO1lBQ2YsYUFBYSxDQUFDLE9BQU8sR0FBRyxhQUFhLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQztZQUNwRCxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNyQzs7Ozs7Ozs7O0lBRUQsT0FBTyxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQztBQUNsQyxDQUFDO0FBdEpELDhCQXNKQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvcmUgfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgUHJvdmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGdldFRlc3RCZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3Rlc3RpbmcnO1xuXG5pbXBvcnQgbmdDb25maWcgZnJvbSAnLi4vY29tbW9uL2NvcmUuY29uZmlnJztcbmltcG9ydCB7IGV4dGVuZENsYXNzLCBmbGF0dGVuIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUuaGVscGVycyc7XG5pbXBvcnQgeyBuZ01vZHVsZVJlc29sdmVyIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUucmVmbGVjdCc7XG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUudHlwZXMnO1xuaW1wb3J0IHsgZ2V0TW9ja2VkTmdEZWZPZiB9IGZyb20gJy4uL2NvbW1vbi9mdW5jLmdldC1tb2NrZWQtbmctZGVmLW9mJztcbmltcG9ydCB7IGlzTmdEZWYgfSBmcm9tICcuLi9jb21tb24vZnVuYy5pcy1uZy1kZWYnO1xuaW1wb3J0IHsgaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMsIE5nTW9kdWxlV2l0aFByb3ZpZGVycyB9IGZyb20gJy4uL2NvbW1vbi9mdW5jLmlzLW5nLW1vZHVsZS1kZWYtd2l0aC1wcm92aWRlcnMnO1xuaW1wb3J0IHsgTW9jayB9IGZyb20gJy4uL2NvbW1vbi9tb2NrJztcbmltcG9ydCB7IE1vY2tPZiB9IGZyb20gJy4uL2NvbW1vbi9tb2NrLW9mJztcbmltcG9ydCBuZ01vY2tzVW5pdmVyc2UgZnJvbSAnLi4vY29tbW9uL25nLW1vY2tzLXVuaXZlcnNlJztcbmltcG9ydCB7IE1vY2tDb21wb25lbnQgfSBmcm9tICcuLi9tb2NrLWNvbXBvbmVudC9tb2NrLWNvbXBvbmVudCc7XG5pbXBvcnQgeyBNb2NrRGlyZWN0aXZlIH0gZnJvbSAnLi4vbW9jay1kaXJlY3RpdmUvbW9jay1kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTW9ja1BpcGUgfSBmcm9tICcuLi9tb2NrLXBpcGUvbW9jay1waXBlJztcbmltcG9ydCBtb2NrU2VydmljZUhlbHBlciBmcm9tICcuLi9tb2NrLXNlcnZpY2UvaGVscGVyJztcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pa2UxOHQvbmctbW9ja3MjaG93LXRvLW1vY2stYS1tb2R1bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1vY2tNb2R1bGU8VD4obW9kdWxlOiBUeXBlPFQ+KTogVHlwZTxUPjtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pa2UxOHQvbmctbW9ja3MjaG93LXRvLW1vY2stYS1tb2R1bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1vY2tNb2R1bGU8VD4obW9kdWxlOiBOZ01vZHVsZVdpdGhQcm92aWRlcnM8VD4pOiBOZ01vZHVsZVdpdGhQcm92aWRlcnM8VD47XG5leHBvcnQgZnVuY3Rpb24gTW9ja01vZHVsZShtb2R1bGU6IGFueSk6IGFueSB7XG4gIGxldCBuZ01vZHVsZTogVHlwZTxhbnk+O1xuICBsZXQgbmdNb2R1bGVQcm92aWRlcnM6IFByb3ZpZGVyW10gfCB1bmRlZmluZWQ7XG4gIGxldCBtb2NrTW9kdWxlOiB0eXBlb2YgbmdNb2R1bGUgfCB1bmRlZmluZWQ7XG4gIGxldCBtb2NrTW9kdWxlUHJvdmlkZXJzOiB0eXBlb2YgbmdNb2R1bGVQcm92aWRlcnM7XG4gIGxldCBtb2NrTW9kdWxlRGVmOiBOZ01vZHVsZSB8IHVuZGVmaW5lZDtcbiAgbGV0IHRvZ2dsZVNraXBNb2NrRmxhZyA9IGZhbHNlO1xuXG4gIGlmIChpc05nTW9kdWxlRGVmV2l0aFByb3ZpZGVycyhtb2R1bGUpKSB7XG4gICAgbmdNb2R1bGUgPSBtb2R1bGUubmdNb2R1bGU7XG4gICAgaWYgKG1vZHVsZS5wcm92aWRlcnMpIHtcbiAgICAgIG5nTW9kdWxlUHJvdmlkZXJzID0gbW9kdWxlLnByb3ZpZGVycztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmdNb2R1bGUgPSBtb2R1bGU7XG4gIH1cblxuICAvLyBXZSBhcmUgaW5zaWRlIG9mIGFuICdpdCcuXG4gIC8vIEl0J3MgZmluZSB0byB0byByZXR1cm4gYSBtb2NrIGNvcHkgb3IgdG8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGl0IHdhc24ndCByZXBsYWNlZCB3aXRoIGl0cyBtb2NrIGNvcHkgaW4gVGVzdEJlZC5cbiAgaWYgKCFuZ01vZHVsZVByb3ZpZGVycyAmJiAoZ2V0VGVzdEJlZCgpIGFzIGFueSkuX2luc3RhbnRpYXRlZCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2V0TW9ja2VkTmdEZWZPZihuZ01vZHVsZSwgJ20nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gbG9va3MgbGlrZSBhbiBpbi10ZXN0IG1vY2suXG4gICAgfVxuICB9XG5cbiAgLy8gRXZlcnkgbW9kdWxlIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGl0cyBtb2NrIGNvcHkgb25seSBvbmNlIHRvIGF2b2lkIGVycm9ycyBsaWtlOlxuICAvLyBGYWlsZWQ6IFR5cGUgLi4uQ29tcG9uZW50IGlzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9ucyBvZiAyIG1vZHVsZXM6IC4uLk1vZHVsZSBhbmQgLi4uTW9kdWxlLi4uXG4gIGlmIChuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdjYWNoZU1vZHVsZScpICYmIG5nTW9ja3NVbml2ZXJzZS5jYWNoZURlY2xhcmF0aW9ucy5oYXMobmdNb2R1bGUpKSB7XG4gICAgbW9ja01vZHVsZSA9IG5nTW9ja3NVbml2ZXJzZS5jYWNoZURlY2xhcmF0aW9ucy5nZXQobmdNb2R1bGUpO1xuICB9XG5cbiAgY29uc3QgcmVzb2x1dGlvbjogdW5kZWZpbmVkIHwgJ21vY2snIHwgJ2tlZXAnIHwgJ3JlcGxhY2UnIHwgJ2V4Y2x1ZGUnID0gbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZ1xuICAgIC5nZXQoJ3Jlc29sdXRpb24nKVxuICAgID8uZ2V0KG5nTW9kdWxlKTtcbiAgaWYgKHJlc29sdXRpb24gPT09ICdtb2NrJyAmJiBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdza2lwTW9jaycpKSB7XG4gICAgdG9nZ2xlU2tpcE1vY2tGbGFnID0gdHJ1ZTtcbiAgICBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuZGVsZXRlKCdza2lwTW9jaycpO1xuICB9XG4gIGlmIChyZXNvbHV0aW9uID09PSAna2VlcCcgJiYgIW5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ3NraXBNb2NrJykpIHtcbiAgICB0b2dnbGVTa2lwTW9ja0ZsYWcgPSB0cnVlO1xuICAgIG5nTW9ja3NVbml2ZXJzZS5mbGFncy5hZGQoJ3NraXBNb2NrJyk7XG4gIH1cbiAgaWYgKHJlc29sdXRpb24gPT09ICdyZXBsYWNlJyAmJiAhbmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmhhcygnc2tpcE1vY2snKSkge1xuICAgIHRvZ2dsZVNraXBNb2NrRmxhZyA9IHRydWU7XG4gICAgbmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmFkZCgnc2tpcE1vY2snKTtcbiAgfVxuXG4gIGlmIChuZ0NvbmZpZy5uZXZlck1vY2tNb2R1bGUuaW5kZXhPZihuZ01vZHVsZSkgIT09IC0xICYmICFuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdza2lwTW9jaycpKSB7XG4gICAgdG9nZ2xlU2tpcE1vY2tGbGFnID0gdHJ1ZTtcbiAgICBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuYWRkKCdza2lwTW9jaycpO1xuICB9XG5cbiAgLy8gTm93IHdlIGNoZWNrIGlmIHdlIG5lZWQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgbW9kdWxlIG9yIHRvIHJlcGxhY2UgaXQgd2l0aCBzb21lIG90aGVyLlxuICBpZiAoIW1vY2tNb2R1bGUgJiYgbmdNb2Nrc1VuaXZlcnNlLmJ1aWx0RGVjbGFyYXRpb25zLmhhcyhuZ01vZHVsZSkpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IG5nTW9ja3NVbml2ZXJzZS5idWlsdERlY2xhcmF0aW9ucy5nZXQobmdNb2R1bGUpO1xuICAgIGlmIChpc05nRGVmKGluc3RhbmNlLCAnbScpICYmIGluc3RhbmNlICE9PSBuZ01vZHVsZSkge1xuICAgICAgbW9ja01vZHVsZSA9IGluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbW9ja01vZHVsZSkge1xuICAgIGxldCBtZXRhOiBjb3JlLk5nTW9kdWxlO1xuICAgIHRyeSB7XG4gICAgICBtZXRhID0gbmdNb2R1bGVSZXNvbHZlci5yZXNvbHZlKG5nTW9kdWxlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduZy1tb2NrcyBpcyBub3QgaW4gSklUIG1vZGUgYW5kIGNhbm5vdCByZXNvbHZlIGRlY2xhcmF0aW9ucycpO1xuICAgIH1cblxuICAgIGNvbnN0IFtjaGFuZ2VkLCBuZ01vZHVsZURlZl0gPSBNb2NrTmdEZWYobWV0YSwgbmdNb2R1bGUpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICBtb2NrTW9kdWxlRGVmID0gbmdNb2R1bGVEZWY7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1vY2tNb2R1bGVEZWYpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdza2lwTW9jaycpID8gbmdNb2R1bGUgOiBNb2NrO1xuICAgIG1vY2tNb2R1bGUgPSBleHRlbmRDbGFzcyhwYXJlbnQpO1xuXG4gICAgLy8gdGhlIGxhc3QgdGhpbmcgaXMgdG8gYXBwbHkgZGVjb3JhdG9ycy5cbiAgICBOZ01vZHVsZShtb2NrTW9kdWxlRGVmKShtb2NrTW9kdWxlIGFzIGFueSk7XG4gICAgTW9ja09mKG5nTW9kdWxlKShtb2NrTW9kdWxlIGFzIGFueSk7XG4gIH1cbiAgaWYgKCFtb2NrTW9kdWxlKSB7XG4gICAgbW9ja01vZHVsZSA9IG5nTW9kdWxlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIGFsd2F5cyBjYWNoZSB0aGUgcmVzdWx0LCBpbiBnbG9iYWwgc2NvcGUgaXQgYWx3YXlzIHdpbGwgYmUgYSBtb2NrLlxuICAvLyBJbiBNb2NrQnVpbGRlciBzY29wZSBpdCB3aWxsIGJlIHJlc2V0IGxhdGVyIGFueXdheS5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ2NhY2hlTW9kdWxlJykpIHtcbiAgICBuZ01vY2tzVW5pdmVyc2UuY2FjaGVEZWNsYXJhdGlvbnMuc2V0KG5nTW9kdWxlLCBtb2NrTW9kdWxlKTtcbiAgfVxuXG4gIGlmIChuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdza2lwTW9jaycpKSB7XG4gICAgbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZy5nZXQoJ2RlcHNTa2lwJyk/LmFkZChtb2NrTW9kdWxlKTtcbiAgfVxuXG4gIGlmIChuZ01vZHVsZVByb3ZpZGVycykge1xuICAgIGNvbnN0IFtjaGFuZ2VkLCBuZ01vZHVsZURlZl0gPSBNb2NrTmdEZWYoeyBwcm92aWRlcnM6IG5nTW9kdWxlUHJvdmlkZXJzIH0pO1xuICAgIG1vY2tNb2R1bGVQcm92aWRlcnMgPSBjaGFuZ2VkID8gbmdNb2R1bGVEZWYucHJvdmlkZXJzIDogbmdNb2R1bGVQcm92aWRlcnM7XG4gIH1cblxuICBpZiAodG9nZ2xlU2tpcE1vY2tGbGFnICYmIG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ3NraXBNb2NrJykpIHtcbiAgICBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuZGVsZXRlKCdza2lwTW9jaycpO1xuICB9IGVsc2UgaWYgKHRvZ2dsZVNraXBNb2NrRmxhZyAmJiAhbmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmhhcygnc2tpcE1vY2snKSkge1xuICAgIG5nTW9ja3NVbml2ZXJzZS5mbGFncy5hZGQoJ3NraXBNb2NrJyk7XG4gIH1cblxuICByZXR1cm4gbW9ja01vZHVsZSA9PT0gbmdNb2R1bGUgJiYgbW9ja01vZHVsZVByb3ZpZGVycyA9PT0gbmdNb2R1bGVQcm92aWRlcnNcbiAgICA/IG1vZHVsZVxuICAgIDogaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMobW9kdWxlKVxuICAgID8geyBuZ01vZHVsZTogbW9ja01vZHVsZSwgLi4uKG1vY2tNb2R1bGVQcm92aWRlcnMgPyB7IHByb3ZpZGVyczogbW9ja01vZHVsZVByb3ZpZGVycyB9IDoge30pIH1cbiAgICA6IG1vY2tNb2R1bGU7XG59XG5cbi8qKlxuICogQ2FuIGJlIGNoYW5nZWQgYXQgYW55IHRpbWUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNb2NrTmdEZWYobmdNb2R1bGVEZWY6IE5nTW9kdWxlLCBuZ01vZHVsZT86IFR5cGU8YW55Pik6IFtib29sZWFuLCBOZ01vZHVsZV0ge1xuICBsZXQgY2hhbmdlZCA9ICFuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdza2lwTW9jaycpO1xuICBjb25zdCBtb2NrTW9kdWxlRGVmOiBOZ01vZHVsZSA9IHt9O1xuICBjb25zdCB7XG4gICAgYm9vdHN0cmFwID0gW10sXG4gICAgZGVjbGFyYXRpb25zID0gW10sXG4gICAgZW50cnlDb21wb25lbnRzID0gW10sXG4gICAgZXhwb3J0cyA9IFtdLFxuICAgIGltcG9ydHMgPSBbXSxcbiAgICBwcm92aWRlcnMgPSBbXSxcbiAgfSA9IG5nTW9kdWxlRGVmO1xuXG4gIGNvbnN0IHJlc29sdXRpb25zID0gbmV3IE1hcCgpO1xuXG4gIC8vIHJlc29sdmVQcm92aWRlciBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIG9mIHRoZSBkZWYgc3RydWN0dXJlLlxuICBjb25zdCByZXNvbHZlUHJvdmlkZXIgPSAoZGVmOiBQcm92aWRlcikgPT5cbiAgICBtb2NrU2VydmljZUhlbHBlci5yZXNvbHZlUHJvdmlkZXIoZGVmLCByZXNvbHV0aW9ucywgKGZsYWc6IGJvb2xlYW4pID0+IHtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGZsYWc7XG4gICAgfSk7XG5cbiAgY29uc3QgcmVzb2x2ZSA9IChkZWY6IGFueSkgPT4ge1xuICAgIGxldCBtb2NrRGVmOiB0eXBlb2YgZGVmO1xuICAgIGlmIChyZXNvbHV0aW9ucy5oYXMoZGVmKSkge1xuICAgICAgcmV0dXJuIHJlc29sdXRpb25zLmdldChkZWYpO1xuICAgIH1cbiAgICAvLyBza2lwcGluZyBleGNsdWRlZCB0aGluZ3NcbiAgICBpZiAobmdNb2Nrc1VuaXZlcnNlLmJ1aWx0RGVjbGFyYXRpb25zLmhhcyhkZWYpICYmIG5nTW9ja3NVbml2ZXJzZS5idWlsdERlY2xhcmF0aW9ucy5nZXQoZGVmKSA9PT0gbnVsbCkge1xuICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgdHJ1ZTtcbiAgICAgIHJlc29sdXRpb25zLnNldChkZWYsIHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmdNb2Nrc1VuaXZlcnNlLnRvdWNoZXMuYWRkKGlzTmdNb2R1bGVEZWZXaXRoUHJvdmlkZXJzKGRlZikgPyBkZWYubmdNb2R1bGUgOiBkZWYpO1xuXG4gICAgLy8gRmlyc3Qgd2UgbW9jayBtb2R1bGVzLlxuICAgIGlmIChpc05nRGVmKGRlZiwgJ20nKSkge1xuICAgICAgbW9ja0RlZiA9IE1vY2tNb2R1bGUoZGVmKTtcbiAgICB9XG4gICAgaWYgKCFtb2NrRGVmICYmIGlzTmdNb2R1bGVEZWZXaXRoUHJvdmlkZXJzKGRlZikpIHtcbiAgICAgIG1vY2tEZWYgPSBNb2NrTW9kdWxlKGRlZik7XG4gICAgICByZXNvbHV0aW9ucy5zZXQoZGVmLm5nTW9kdWxlLCBtb2NrRGVmLm5nTW9kdWxlKTtcbiAgICB9XG5cbiAgICAvLyBUaGVuIHdlIGNoZWNrIGRlY2lzaW9ucyB3aGV0aGVyIHdlIHNob3VsZCBrZWVwIG9yIHJlcGxhY2UgYSBkZWYuXG4gICAgaWYgKCFtb2NrRGVmICYmIG5nTW9ja3NVbml2ZXJzZS5idWlsdERlY2xhcmF0aW9ucy5oYXMoZGVmKSkge1xuICAgICAgbW9ja0RlZiA9IG5nTW9ja3NVbml2ZXJzZS5idWlsdERlY2xhcmF0aW9ucy5nZXQoZGVmKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgdGhlbiB3ZSBtb2NrIHdoYXQgd2UgaGF2ZSBpZiBpdCB3YXNuJ3QgYmxvY2tlZCBieSB0aGUgc2tpcE1vY2suXG4gICAgaWYgKCFtb2NrRGVmICYmIG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ3NraXBNb2NrJykpIHtcbiAgICAgIG1vY2tEZWYgPSBkZWY7XG4gICAgfVxuICAgIGlmICghbW9ja0RlZiAmJiBpc05nRGVmKGRlZiwgJ2MnKSkge1xuICAgICAgbW9ja0RlZiA9IE1vY2tDb21wb25lbnQoZGVmKTtcbiAgICB9XG4gICAgaWYgKCFtb2NrRGVmICYmIGlzTmdEZWYoZGVmLCAnZCcpKSB7XG4gICAgICBtb2NrRGVmID0gTW9ja0RpcmVjdGl2ZShkZWYpO1xuICAgIH1cbiAgICBpZiAoIW1vY2tEZWYgJiYgaXNOZ0RlZihkZWYsICdwJykpIHtcbiAgICAgIG1vY2tEZWYgPSBNb2NrUGlwZShkZWYpO1xuICAgIH1cblxuICAgIGlmIChuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdza2lwTW9jaycpKSB7XG4gICAgICBuZ01vY2tzVW5pdmVyc2UuY29uZmlnLmdldCgnZGVwc1NraXAnKT8uYWRkKG1vY2tEZWYpO1xuICAgIH1cblxuICAgIHJlc29sdXRpb25zLnNldChkZWYsIG1vY2tEZWYpO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG1vY2tEZWYgIT09IGRlZjtcbiAgICByZXR1cm4gbW9ja0RlZjtcbiAgfTtcblxuICBpZiAoZGVjbGFyYXRpb25zICYmIGRlY2xhcmF0aW9ucy5sZW5ndGgpIHtcbiAgICBtb2NrTW9kdWxlRGVmLmRlY2xhcmF0aW9ucyA9IGZsYXR0ZW4oZGVjbGFyYXRpb25zKVxuICAgICAgLm1hcChyZXNvbHZlKVxuICAgICAgLmZpbHRlcihkZWNsYXJhdGlvbiA9PiBkZWNsYXJhdGlvbik7XG4gIH1cblxuICBpZiAoZW50cnlDb21wb25lbnRzICYmIGVudHJ5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICBtb2NrTW9kdWxlRGVmLmVudHJ5Q29tcG9uZW50cyA9IGZsYXR0ZW4oZW50cnlDb21wb25lbnRzKVxuICAgICAgLm1hcChyZXNvbHZlKVxuICAgICAgLmZpbHRlcihkZWNsYXJhdGlvbiA9PiBkZWNsYXJhdGlvbik7XG4gIH1cblxuICBpZiAoYm9vdHN0cmFwICYmIGJvb3RzdHJhcC5sZW5ndGgpIHtcbiAgICBtb2NrTW9kdWxlRGVmLmJvb3RzdHJhcCA9IGZsYXR0ZW4oYm9vdHN0cmFwKVxuICAgICAgLm1hcChyZXNvbHZlKVxuICAgICAgLmZpbHRlcihkZWNsYXJhdGlvbiA9PiBkZWNsYXJhdGlvbik7XG4gIH1cblxuICBpZiAocHJvdmlkZXJzICYmIHByb3ZpZGVycy5sZW5ndGgpIHtcbiAgICBtb2NrTW9kdWxlRGVmLnByb3ZpZGVycyA9IGZsYXR0ZW4ocHJvdmlkZXJzKVxuICAgICAgLm1hcChyZXNvbHZlUHJvdmlkZXIpXG4gICAgICAuZmlsdGVyKGRlY2xhcmF0aW9uID0+IGRlY2xhcmF0aW9uKTtcbiAgfVxuXG4gIC8vIG1vY2sgaW1wb3J0cyBzaG91bGQgYmUgdGhlIGxhdGVzdCBzdGVwIGJlZm9yZSBleHBvcnRzIHRvIGVuc3VyZVxuICAvLyB0aGF0IGV2ZXJ5dGhpbmcgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBpdHMgbW9jayBjb3B5IGFscmVhZHlcbiAgaWYgKGltcG9ydHMgJiYgaW1wb3J0cy5sZW5ndGgpIHtcbiAgICBtb2NrTW9kdWxlRGVmLmltcG9ydHMgPSBmbGF0dGVuKGltcG9ydHMpXG4gICAgICAubWFwKHJlc29sdmUpXG4gICAgICAuZmlsdGVyKGRlY2xhcmF0aW9uID0+IGRlY2xhcmF0aW9uKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgZXhwb3J0cy5cbiAgaWYgKGV4cG9ydHMgJiYgZXhwb3J0cy5sZW5ndGgpIHtcbiAgICBtb2NrTW9kdWxlRGVmLmV4cG9ydHMgPSBmbGF0dGVuKGV4cG9ydHMpXG4gICAgICAubWFwKHJlc29sdmUpXG4gICAgICAuZmlsdGVyKGRlY2xhcmF0aW9uID0+IGRlY2xhcmF0aW9uKTtcbiAgfVxuXG4gIC8vIGlmIHdlIGFyZSBpbiB0aGUgc2tpcE1vY2sgbW9kZSB3ZSBuZWVkIHRvIGV4cG9ydCBvbmx5IHRoZSBkZWZhdWx0IGV4cG9ydHMuXG4gIC8vIGlmIHdlIGFyZSBpbiB0aGUgY29ycmVjdE1vZHVsZUV4cG9ydHMgbW9kZSB3ZSBuZWVkIHRvIGV4cG9ydCBvbmx5IGRlZmF1bHQgZXhwb3J0cy5cbiAgY29uc3QgY29ycmVjdEV4cG9ydHMgPSBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdza2lwTW9jaycpIHx8IG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ2NvcnJlY3RNb2R1bGVFeHBvcnRzJyk7XG5cbiAgLy8gV2hlbiB3ZSBtb2NrIGEgbW9kdWxlLCBvbmx5IGV4cG9ydGVkIGRlY2xhcmF0aW9ucyBhcmUgYWNjZXNzaWJsZSBpbnNpZGUgb2YgYSB0ZXN0LlxuICAvLyBCZWNhdXNlIG9mIHRoYXQgd2UgaGF2ZSB0byBleHBvcnQgd2hhdGV2ZXIgYSBtb2R1bGUgaW1wb3J0cyBvciBkZWNsYXJlcy5cbiAgLy8gVW5mb3J0dW5hdGVseSwgaW4gdGhpcyBjYXNlIHRlc3RzIHdvbid0IGZhaWwgd2hlbiBhIG1vZHVsZSBoYXMgbWlzc2VkIGV4cG9ydHMuXG4gIC8vIE1vY2tCdWlsZGVyIGRvZXNuJ3QgaGF2ZSBoYXZlIHRoaXMgaXNzdWUuXG4gIGZvciAoY29uc3QgZGVmIG9mIGZsYXR0ZW4oW2ltcG9ydHMsIGRlY2xhcmF0aW9uc10pKSB7XG4gICAgY29uc3QgbW9kdWxlQ29uZmlnID0gbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZy5nZXQobmdNb2R1bGUpIHx8IHt9O1xuICAgIGNvbnN0IGluc3RhbmNlID0gaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMoZGVmKSA/IGRlZi5uZ01vZHVsZSA6IGRlZjtcbiAgICBjb25zdCBtb2NrRGVmID0gcmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgaWYgKCFtb2NrRGVmKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBleHBvcnQgYSBkZWNsYXJhdGlvbiwgdGhlbiB3ZSBoYXZlIHRvIGV4cG9ydCBpdHMgbW9kdWxlIHRvby5cbiAgICBjb25zdCBjb25maWcgPSBuZ01vY2tzVW5pdmVyc2UuY29uZmlnLmdldChpbnN0YW5jZSkgfHwge307XG4gICAgaWYgKGNvbmZpZy5leHBvcnQgJiYgbmdNb2R1bGUpIHtcbiAgICAgIGlmICghbW9kdWxlQ29uZmlnLmV4cG9ydCkge1xuICAgICAgICBuZ01vY2tzVW5pdmVyc2UuY29uZmlnLnNldChuZ01vZHVsZSwge1xuICAgICAgICAgIC4uLm1vZHVsZUNvbmZpZyxcbiAgICAgICAgICBleHBvcnQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3JyZWN0RXhwb3J0cyAmJiAhY29uZmlnLmV4cG9ydCAmJiAhbW9kdWxlQ29uZmlnLmV4cG9ydEFsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtb2NrTW9kdWxlRGVmLmV4cG9ydHMgJiYgbW9ja01vZHVsZURlZi5leHBvcnRzLmluZGV4T2YobW9ja0RlZikgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBtb2NrTW9kdWxlRGVmLmV4cG9ydHMgPSBtb2NrTW9kdWxlRGVmLmV4cG9ydHMgfHwgW107XG4gICAgbW9ja01vZHVsZURlZi5leHBvcnRzLnB1c2gobW9ja0RlZik7XG4gIH1cblxuICByZXR1cm4gW2NoYW5nZWQsIG1vY2tNb2R1bGVEZWZdO1xufVxuIl19