"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockDirective = exports.MockDirectives = void 0;
var core_1 = require("@angular/core");
var testing_1 = require("@angular/core/testing");
var forms_1 = require("@angular/forms");
var core_helpers_1 = require("../common/core.helpers");
var core_reflect_1 = require("../common/core.reflect");
var decorate_inputs_1 = require("../common/decorate.inputs");
var decorate_outputs_1 = require("../common/decorate.outputs");
var decorate_queries_1 = require("../common/decorate.queries");
var func_get_mocked_ng_def_of_1 = require("../common/func.get-mocked-ng-def-of");
var mock_control_value_accessor_1 = require("../common/mock-control-value-accessor");
var mock_of_1 = require("../common/mock-of");
var ng_mocks_universe_1 = require("../common/ng-mocks-universe");
var helper_1 = require("../mock-service/helper");
function MockDirectives() {
    var directives = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        directives[_i] = arguments[_i];
    }
    return directives.map(MockDirective);
}
exports.MockDirectives = MockDirectives;
function MockDirective(directive) {
    var e_1, _a;
    // We are inside of an 'it'.
    // It's fine to to return a mock copy or to throw an exception if it wasn't replaced with its mock copy in TestBed.
    if (testing_1.getTestBed()._instantiated) {
        try {
            return func_get_mocked_ng_def_of_1.getMockedNgDefOf(directive, 'd');
        }
        catch (error) {
            // looks like an in-test mock.
        }
    }
    if (ng_mocks_universe_1.default.flags.has('cacheDirective') && ng_mocks_universe_1.default.cacheDeclarations.has(directive)) {
        return ng_mocks_universe_1.default.cacheDeclarations.get(directive);
    }
    var meta;
    try {
        meta = core_reflect_1.directiveResolver.resolve(directive);
    }
    catch (e) {
        /* istanbul ignore next */
        throw new Error('ng-mocks is not in JIT mode and cannot resolve declarations');
    }
    var selector = meta.selector, exportAs = meta.exportAs, inputs = meta.inputs, outputs = meta.outputs, queries = meta.queries, providers = meta.providers;
    var options = {
        exportAs: exportAs,
        providers: [
            {
                provide: directive,
                useExisting: (function () {
                    var value = core_1.forwardRef(function () { return DirectiveMock; });
                    value.__ngMocksSkip = true;
                    return value;
                })(),
            },
        ],
        selector: selector,
    };
    var resolutions = new Map();
    var resolveProvider = function (def) { return helper_1.default.resolveProvider(def, resolutions); };
    var setNgValueAccessor;
    try {
        for (var _b = __values(core_helpers_1.flatten(providers || [])), _c = _b.next(); !_c.done; _c = _b.next()) {
            var providerDef = _c.value;
            var provide = providerDef && typeof providerDef === 'object' && providerDef.provide ? providerDef.provide : providerDef;
            if (options.providers && provide === forms_1.NG_VALIDATORS) {
                options.providers.push({
                    multi: true,
                    provide: provide,
                    useExisting: (function () {
                        var value = core_1.forwardRef(function () { return DirectiveMock; });
                        value.__ngMocksSkip = true;
                        return value;
                    })(),
                });
                continue;
            }
            if (setNgValueAccessor === undefined && options.providers && provide === forms_1.NG_VALUE_ACCESSOR) {
                setNgValueAccessor = false;
                options.providers.push({
                    multi: true,
                    provide: provide,
                    useExisting: (function () {
                        var value = core_1.forwardRef(function () { return DirectiveMock; });
                        value.__ngMocksSkip = true;
                        return value;
                    })(),
                });
                continue;
            }
            var mock = resolveProvider(providerDef);
            /* istanbul ignore else */
            if (options.providers && mock) {
                options.providers.push(mock);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (setNgValueAccessor === undefined) {
        setNgValueAccessor =
            helper_1.default.extractMethodsFromPrototype(directive.prototype).indexOf('writeValue') !== -1;
    }
    var config = ng_mocks_universe_1.default.config.get(directive);
    var DirectiveMock = /** @class */ (function (_super) {
        __extends(DirectiveMock, _super);
        /* istanbul ignore next */
        function DirectiveMock(injector, element, template, viewContainer) {
            var _this = _super.call(this, injector) || this;
            _this.__ngMocksInstall(element, template, viewContainer);
            return _this;
        }
        DirectiveMock.prototype.ngOnInit = function () {
            if (config && config.render) {
                var _a = config.render !== true
                    ? config.render
                    : {
                        $implicit: undefined,
                        variables: {},
                    }, $implicit = _a.$implicit, variables = _a.variables;
                this.__render($implicit, variables);
            }
        };
        DirectiveMock.prototype.__ngMocksInstall = function (element, template, viewContainer) {
            // Basically any directive on ng-template is treated as structural, even it doesn't control render process.
            // In our case we don't if we should render it or not and due to this we do nothing.
            this.__element = element;
            this.__template = template;
            this.__viewContainer = viewContainer;
            this.__isStructural = template && viewContainer;
            // Providing method to render mock values.
            this.__render = function ($implicit, variables) {
                if (viewContainer && template) {
                    viewContainer.clear();
                    viewContainer.createEmbeddedView(template, __assign(__assign({}, variables), { $implicit: $implicit }));
                }
            };
        };
        DirectiveMock = __decorate([
            core_1.Directive(options),
            mock_of_1.MockOf(directive, { outputs: outputs, setNgValueAccessor: setNgValueAccessor }),
            __param(1, core_1.Optional()),
            __param(2, core_1.Optional()),
            __param(3, core_1.Optional()),
            __metadata("design:paramtypes", [core_1.Injector,
                core_1.ElementRef,
                core_1.TemplateRef,
                core_1.ViewContainerRef])
        ], DirectiveMock);
        return DirectiveMock;
    }(mock_control_value_accessor_1.MockControlValueAccessor));
    /* istanbul ignore else */
    if (queries) {
        decorate_inputs_1.default(DirectiveMock, inputs, Object.keys(queries));
    }
    decorate_outputs_1.default(DirectiveMock, outputs);
    decorate_queries_1.default(DirectiveMock, queries);
    /* istanbul ignore else */
    if (ng_mocks_universe_1.default.flags.has('cacheDirective')) {
        ng_mocks_universe_1.default.cacheDeclarations.set(directive, DirectiveMock);
    }
    return DirectiveMock;
}
exports.MockDirective = MockDirective;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvbW9jay1kaXJlY3RpdmUvbW9jay1kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxzQ0FVdUI7QUFDdkIsaURBQW1EO0FBQ25ELHdDQUFrRTtBQUVsRSx1REFBaUQ7QUFDakQsdURBQTJEO0FBRTNELDZEQUF1RDtBQUN2RCwrREFBeUQ7QUFDekQsK0RBQXlEO0FBQ3pELGlGQUF1RTtBQUN2RSxxRkFBaUY7QUFDakYsNkNBQTJDO0FBQzNDLGlFQUEwRDtBQUMxRCxpREFBdUQ7QUFJdkQsU0FBZ0IsY0FBYztJQUFDLG9CQUErQjtTQUEvQixVQUErQixFQUEvQixxQkFBK0IsRUFBL0IsSUFBK0I7UUFBL0IsK0JBQStCOztJQUM1RCxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdkMsQ0FBQztBQUZELHdDQUVDO0FBTUQsU0FBZ0IsYUFBYSxDQUFhLFNBQTJCOztJQUNuRSw0QkFBNEI7SUFDNUIsbUhBQW1IO0lBQ25ILElBQUssb0JBQVUsRUFBVSxDQUFDLGFBQWEsRUFBRTtRQUN2QyxJQUFJO1lBQ0YsT0FBTyw0Q0FBZ0IsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDekM7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNkLDhCQUE4QjtTQUMvQjtLQUNGO0lBQ0QsSUFBSSwyQkFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsSUFBSSwyQkFBZSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUNuRyxPQUFPLDJCQUFlLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ3pEO0lBRUQsSUFBSSxJQUFvQixDQUFDO0lBQ3pC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LGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUM7S0FDakU7SUFFRCxPQUFPLGFBQW9CLENBQUM7QUFDOUIsQ0FBQztBQWxKRCxzQ0FrSkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb3JlIH0gZnJvbSAnQGFuZ3VsYXIvY29tcGlsZXInO1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBmb3J3YXJkUmVmLFxuICBJbmplY3RvcixcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgUHJvdmlkZXIsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGdldFRlc3RCZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3Rlc3RpbmcnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICcuLi9jb21tb24vY29yZS5oZWxwZXJzJztcbmltcG9ydCB7IGRpcmVjdGl2ZVJlc29sdmVyIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUucmVmbGVjdCc7XG5pbXBvcnQgeyBBbnlUeXBlLCBUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUudHlwZXMnO1xuaW1wb3J0IGRlY29yYXRlSW5wdXRzIGZyb20gJy4uL2NvbW1vbi9kZWNvcmF0ZS5pbnB1dHMnO1xuaW1wb3J0IGRlY29yYXRlT3V0cHV0cyBmcm9tICcuLi9jb21tb24vZGVjb3JhdGUub3V0cHV0cyc7XG5pbXBvcnQgZGVjb3JhdGVRdWVyaWVzIGZyb20gJy4uL2NvbW1vbi9kZWNvcmF0ZS5xdWVyaWVzJztcbmltcG9ydCB7IGdldE1vY2tlZE5nRGVmT2YgfSBmcm9tICcuLi9jb21tb24vZnVuYy5nZXQtbW9ja2VkLW5nLWRlZi1vZic7XG5pbXBvcnQgeyBNb2NrQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICcuLi9jb21tb24vbW9jay1jb250cm9sLXZhbHVlLWFjY2Vzc29yJztcbmltcG9ydCB7IE1vY2tPZiB9IGZyb20gJy4uL2NvbW1vbi9tb2NrLW9mJztcbmltcG9ydCBuZ01vY2tzVW5pdmVyc2UgZnJvbSAnLi4vY29tbW9uL25nLW1vY2tzLXVuaXZlcnNlJztcbmltcG9ydCBtb2NrU2VydmljZUhlbHBlciBmcm9tICcuLi9tb2NrLXNlcnZpY2UvaGVscGVyJztcblxuaW1wb3J0IHsgTW9ja2VkRGlyZWN0aXZlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBNb2NrRGlyZWN0aXZlcyguLi5kaXJlY3RpdmVzOiBBcnJheTxUeXBlPGFueT4+KTogQXJyYXk8VHlwZTxNb2NrZWREaXJlY3RpdmU8YW55Pj4+IHtcbiAgcmV0dXJuIGRpcmVjdGl2ZXMubWFwKE1vY2tEaXJlY3RpdmUpO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2lrZTE4dC9uZy1tb2NrcyNob3ctdG8tbW9jay1hLWRpcmVjdGl2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gTW9ja0RpcmVjdGl2ZTxURGlyZWN0aXZlPihkaXJlY3RpdmU6IEFueVR5cGU8VERpcmVjdGl2ZT4pOiBUeXBlPE1vY2tlZERpcmVjdGl2ZTxURGlyZWN0aXZlPj47XG5leHBvcnQgZnVuY3Rpb24gTW9ja0RpcmVjdGl2ZTxURGlyZWN0aXZlPihkaXJlY3RpdmU6IFR5cGU8VERpcmVjdGl2ZT4pOiBUeXBlPE1vY2tlZERpcmVjdGl2ZTxURGlyZWN0aXZlPj4ge1xuICAvLyBXZSBhcmUgaW5zaWRlIG9mIGFuICdpdCcuXG4gIC8vIEl0J3MgZmluZSB0byB0byByZXR1cm4gYSBtb2NrIGNvcHkgb3IgdG8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGl0IHdhc24ndCByZXBsYWNlZCB3aXRoIGl0cyBtb2NrIGNvcHkgaW4gVGVzdEJlZC5cbiAgaWYgKChnZXRUZXN0QmVkKCkgYXMgYW55KS5faW5zdGFudGlhdGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZXRNb2NrZWROZ0RlZk9mKGRpcmVjdGl2ZSwgJ2QnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gbG9va3MgbGlrZSBhbiBpbi10ZXN0IG1vY2suXG4gICAgfVxuICB9XG4gIGlmIChuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdjYWNoZURpcmVjdGl2ZScpICYmIG5nTW9ja3NVbml2ZXJzZS5jYWNoZURlY2xhcmF0aW9ucy5oYXMoZGlyZWN0aXZlKSkge1xuICAgIHJldHVybiBuZ01vY2tzVW5pdmVyc2UuY2FjaGVEZWNsYXJhdGlvbnMuZ2V0KGRpcmVjdGl2ZSk7XG4gIH1cblxuICBsZXQgbWV0YTogY29yZS5EaXJlY3RpdmU7XG4gIHRyeSB7XG4gICAgbWV0YSA9IGRpcmVjdGl2ZVJlc29sdmVyLnJlc29sdmUoZGlyZWN0aXZlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKCduZy1tb2NrcyBpcyBub3QgaW4gSklUIG1vZGUgYW5kIGNhbm5vdCByZXNvbHZlIGRlY2xhcmF0aW9ucycpO1xuICB9XG4gIGNvbnN0IHsgc2VsZWN0b3IsIGV4cG9ydEFzLCBpbnB1dHMsIG91dHB1dHMsIHF1ZXJpZXMsIHByb3ZpZGVycyB9ID0gbWV0YTtcblxuICBjb25zdCBvcHRpb25zOiBEaXJlY3RpdmUgPSB7XG4gICAgZXhwb3J0QXMsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICB7XG4gICAgICAgIHByb3ZpZGU6IGRpcmVjdGl2ZSxcbiAgICAgICAgdXNlRXhpc3Rpbmc6ICgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWU6IFR5cGU8YW55PiAmIHsgX19uZ01vY2tzU2tpcD86IGJvb2xlYW4gfSA9IGZvcndhcmRSZWYoKCkgPT4gRGlyZWN0aXZlTW9jayk7XG4gICAgICAgICAgdmFsdWUuX19uZ01vY2tzU2tpcCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KSgpLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHNlbGVjdG9yLFxuICB9O1xuXG4gIGNvbnN0IHJlc29sdXRpb25zID0gbmV3IE1hcCgpO1xuICBjb25zdCByZXNvbHZlUHJvdmlkZXIgPSAoZGVmOiBQcm92aWRlcikgPT4gbW9ja1NlcnZpY2VIZWxwZXIucmVzb2x2ZVByb3ZpZGVyKGRlZiwgcmVzb2x1dGlvbnMpO1xuXG4gIGxldCBzZXROZ1ZhbHVlQWNjZXNzb3I6IHVuZGVmaW5lZCB8IGJvb2xlYW47XG4gIGZvciAoY29uc3QgcHJvdmlkZXJEZWYgb2YgZmxhdHRlbihwcm92aWRlcnMgfHwgW10pKSB7XG4gICAgY29uc3QgcHJvdmlkZSA9XG4gICAgICBwcm92aWRlckRlZiAmJiB0eXBlb2YgcHJvdmlkZXJEZWYgPT09ICdvYmplY3QnICYmIHByb3ZpZGVyRGVmLnByb3ZpZGUgPyBwcm92aWRlckRlZi5wcm92aWRlIDogcHJvdmlkZXJEZWY7XG4gICAgaWYgKG9wdGlvbnMucHJvdmlkZXJzICYmIHByb3ZpZGUgPT09IE5HX1ZBTElEQVRPUlMpIHtcbiAgICAgIG9wdGlvbnMucHJvdmlkZXJzLnB1c2goe1xuICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgcHJvdmlkZSxcbiAgICAgICAgdXNlRXhpc3Rpbmc6ICgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWU6IFR5cGU8YW55PiAmIHsgX19uZ01vY2tzU2tpcD86IGJvb2xlYW4gfSA9IGZvcndhcmRSZWYoKCkgPT4gRGlyZWN0aXZlTW9jayk7XG4gICAgICAgICAgdmFsdWUuX19uZ01vY2tzU2tpcCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KSgpLFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNldE5nVmFsdWVBY2Nlc3NvciA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucHJvdmlkZXJzICYmIHByb3ZpZGUgPT09IE5HX1ZBTFVFX0FDQ0VTU09SKSB7XG4gICAgICBzZXROZ1ZhbHVlQWNjZXNzb3IgPSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucHJvdmlkZXJzLnB1c2goe1xuICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgcHJvdmlkZSxcbiAgICAgICAgdXNlRXhpc3Rpbmc6ICgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWU6IFR5cGU8YW55PiAmIHsgX19uZ01vY2tzU2tpcD86IGJvb2xlYW4gfSA9IGZvcndhcmRSZWYoKCkgPT4gRGlyZWN0aXZlTW9jayk7XG4gICAgICAgICAgdmFsdWUuX19uZ01vY2tzU2tpcCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KSgpLFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBtb2NrID0gcmVzb2x2ZVByb3ZpZGVyKHByb3ZpZGVyRGVmKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChvcHRpb25zLnByb3ZpZGVycyAmJiBtb2NrKSB7XG4gICAgICBvcHRpb25zLnByb3ZpZGVycy5wdXNoKG1vY2spO1xuICAgIH1cbiAgfVxuICBpZiAoc2V0TmdWYWx1ZUFjY2Vzc29yID09PSB1bmRlZmluZWQpIHtcbiAgICBzZXROZ1ZhbHVlQWNjZXNzb3IgPVxuICAgICAgbW9ja1NlcnZpY2VIZWxwZXIuZXh0cmFjdE1ldGhvZHNGcm9tUHJvdG90eXBlKGRpcmVjdGl2ZS5wcm90b3R5cGUpLmluZGV4T2YoJ3dyaXRlVmFsdWUnKSAhPT0gLTE7XG4gIH1cblxuICBjb25zdCBjb25maWcgPSBuZ01vY2tzVW5pdmVyc2UuY29uZmlnLmdldChkaXJlY3RpdmUpO1xuXG4gIEBEaXJlY3RpdmUob3B0aW9ucylcbiAgQE1vY2tPZihkaXJlY3RpdmUsIHsgb3V0cHV0cywgc2V0TmdWYWx1ZUFjY2Vzc29yIH0pXG4gIGNsYXNzIERpcmVjdGl2ZU1vY2sgZXh0ZW5kcyBNb2NrQ29udHJvbFZhbHVlQWNjZXNzb3IgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICBAT3B0aW9uYWwoKSBlbGVtZW50PzogRWxlbWVudFJlZixcbiAgICAgIEBPcHRpb25hbCgpIHRlbXBsYXRlPzogVGVtcGxhdGVSZWY8YW55PixcbiAgICAgIEBPcHRpb25hbCgpIHZpZXdDb250YWluZXI/OiBWaWV3Q29udGFpbmVyUmVmXG4gICAgKSB7XG4gICAgICBzdXBlcihpbmplY3Rvcik7XG4gICAgICB0aGlzLl9fbmdNb2Nrc0luc3RhbGwoZWxlbWVudCwgdGVtcGxhdGUsIHZpZXdDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcucmVuZGVyKSB7XG4gICAgICAgIGNvbnN0IHsgJGltcGxpY2l0LCB2YXJpYWJsZXMgfSA9XG4gICAgICAgICAgY29uZmlnLnJlbmRlciAhPT0gdHJ1ZVxuICAgICAgICAgICAgPyBjb25maWcucmVuZGVyXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHt9LFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAodGhpcyBhcyBhbnkpLl9fcmVuZGVyKCRpbXBsaWNpdCwgdmFyaWFibGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9fbmdNb2Nrc0luc3RhbGwoXG4gICAgICBlbGVtZW50PzogRWxlbWVudFJlZixcbiAgICAgIHRlbXBsYXRlPzogVGVtcGxhdGVSZWY8YW55PixcbiAgICAgIHZpZXdDb250YWluZXI/OiBWaWV3Q29udGFpbmVyUmVmXG4gICAgKTogdm9pZCB7XG4gICAgICAvLyBCYXNpY2FsbHkgYW55IGRpcmVjdGl2ZSBvbiBuZy10ZW1wbGF0ZSBpcyB0cmVhdGVkIGFzIHN0cnVjdHVyYWwsIGV2ZW4gaXQgZG9lc24ndCBjb250cm9sIHJlbmRlciBwcm9jZXNzLlxuICAgICAgLy8gSW4gb3VyIGNhc2Ugd2UgZG9uJ3QgaWYgd2Ugc2hvdWxkIHJlbmRlciBpdCBvciBub3QgYW5kIGR1ZSB0byB0aGlzIHdlIGRvIG5vdGhpbmcuXG4gICAgICAodGhpcyBhcyBhbnkpLl9fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAodGhpcyBhcyBhbnkpLl9fdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICh0aGlzIGFzIGFueSkuX192aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcbiAgICAgICh0aGlzIGFzIGFueSkuX19pc1N0cnVjdHVyYWwgPSB0ZW1wbGF0ZSAmJiB2aWV3Q29udGFpbmVyO1xuXG4gICAgICAvLyBQcm92aWRpbmcgbWV0aG9kIHRvIHJlbmRlciBtb2NrIHZhbHVlcy5cbiAgICAgICh0aGlzIGFzIGFueSkuX19yZW5kZXIgPSAoJGltcGxpY2l0PzogYW55LCB2YXJpYWJsZXM/OiBSZWNvcmQ8a2V5b2YgYW55LCBhbnk+KSA9PiB7XG4gICAgICAgIGlmICh2aWV3Q29udGFpbmVyICYmIHRlbXBsYXRlKSB7XG4gICAgICAgICAgdmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgIHZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRlbXBsYXRlLCB7IC4uLnZhcmlhYmxlcywgJGltcGxpY2l0IH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChxdWVyaWVzKSB7XG4gICAgZGVjb3JhdGVJbnB1dHMoRGlyZWN0aXZlTW9jaywgaW5wdXRzLCBPYmplY3Qua2V5cyhxdWVyaWVzKSk7XG4gIH1cbiAgZGVjb3JhdGVPdXRwdXRzKERpcmVjdGl2ZU1vY2ssIG91dHB1dHMpO1xuICBkZWNvcmF0ZVF1ZXJpZXMoRGlyZWN0aXZlTW9jaywgcXVlcmllcyk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ2NhY2hlRGlyZWN0aXZlJykpIHtcbiAgICBuZ01vY2tzVW5pdmVyc2UuY2FjaGVEZWNsYXJhdGlvbnMuc2V0KGRpcmVjdGl2ZSwgRGlyZWN0aXZlTW9jayk7XG4gIH1cblxuICByZXR1cm4gRGlyZWN0aXZlTW9jayBhcyBhbnk7XG59XG4iXX0=