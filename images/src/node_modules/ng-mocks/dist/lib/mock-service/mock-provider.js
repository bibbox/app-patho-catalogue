"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_config_1 = require("../common/core.config");
var func_is_ng_injection_token_1 = require("../common/func.is-ng-injection-token");
var ng_mocks_universe_1 = require("../common/ng-mocks-universe");
var helper_use_factory_1 = require("./helper.use-factory");
var mock_service_1 = require("./mock-service");
var neverMockProvidedFunction = core_config_1.default.neverMockProvidedFunction, neverMockToken = core_config_1.default.neverMockToken;
function default_1(provider) {
    var provide = typeof provider === 'object' && provider.provide ? provider.provide : provider;
    if (typeof provide === 'function' && neverMockProvidedFunction.indexOf(provide.name) !== -1) {
        return provider;
    }
    if (func_is_ng_injection_token_1.isNgInjectionToken(provide) && neverMockToken.indexOf(provide.toString()) !== -1) {
        return undefined;
    }
    // Only pure provides should be cached to avoid their influence on
    // another different declarations.
    if (provide === provider &&
        ng_mocks_universe_1.default.flags.has('cacheProvider') &&
        ng_mocks_universe_1.default.cacheProviders.has(provide)) {
        return ng_mocks_universe_1.default.cacheProviders.get(provide);
    }
    var mockProvider;
    if (typeof provide === 'function') {
        mockProvider = helper_use_factory_1.default(provide, function () {
            var e_1, _a;
            var instance = mock_service_1.MockService(provide);
            // Magic below adds missed properties to the instance to
            // fulfill missed abstract methods.
            if (provide !== provider && Object.keys(provider).indexOf('useClass') !== -1) {
                var existing = Object.getOwnPropertyNames(instance);
                var child = mock_service_1.MockService(provider.useClass);
                try {
                    for (var _b = __values(Object.getOwnPropertyNames(child)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var name_1 = _c.value;
                        if (existing.indexOf(name_1) !== -1) {
                            continue;
                        }
                        var def = Object.getOwnPropertyDescriptor(child, name_1);
                        /* istanbul ignore else */
                        if (def) {
                            Object.defineProperty(instance, name_1, def);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return instance;
        });
    }
    if (provide === provider && mockProvider && ng_mocks_universe_1.default.flags.has('cacheProvider')) {
        ng_mocks_universe_1.default.cacheProviders.set(provide, mockProvider);
    }
    if (mockProvider) {
        return mockProvider;
    }
    // Not sure if this case is possible, all classes should be already
    // replaced with their mock coplies by the code above, below we
    // should have only tokens and string literals with a proper definition.
    if (provide === provider) {
        return undefined;
    }
    // Tokens are special subject, we can skip adding them because in a mock module they are useless.
    // The main problem is that providing undefined to HTTP_INTERCEPTORS and others breaks their code.
    // If a testing module / component requires omitted tokens then they should be provided manually
    // during creation of TestBed module.
    if (provider.multi) {
        if (ng_mocks_universe_1.default.config.has('multi')) {
            ng_mocks_universe_1.default.config.get('multi').add(provide);
        }
        return undefined;
    }
    // if a token has a primitive type, we can return its initial state.
    if (Object.keys(provider).indexOf('useValue') !== -1) {
        mockProvider =
            provider.useValue && typeof provider.useValue === 'object'
                ? helper_use_factory_1.default(provide, function () { return mock_service_1.MockService(provider.useValue); })
                : {
                    provide: provide,
                    useValue: typeof provider.useValue === 'boolean'
                        ? false
                        : typeof provider.useValue === 'number'
                            ? 0
                            : typeof provider.useValue === 'string'
                                ? ''
                                : provider.useValue === null
                                    ? null
                                    : undefined,
                };
    }
    if (!mockProvider && Object.keys(provider).indexOf('useExisting') !== -1) {
        mockProvider = provider;
    }
    if (!mockProvider && Object.keys(provider).indexOf('useClass') !== -1) {
        mockProvider =
            ng_mocks_universe_1.default.builtProviders.has(provider.useClass) &&
                ng_mocks_universe_1.default.builtProviders.get(provider.useClass) === provider.useClass
                ? provider
                : helper_use_factory_1.default(provide, function () { return mock_service_1.MockService(provider.useClass); });
    }
    if (!mockProvider && Object.keys(provider).indexOf('useFactory') !== -1) {
        mockProvider = helper_use_factory_1.default(provide, function () { return ({}); });
    }
    return mockProvider;
}
exports.default = default_1;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9tb2NrLXNlcnZpY2UvbW9jay1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRUEscURBQTZDO0FBQzdDLG1GQUEwRTtBQUMxRSxpRUFBMEQ7QUFFMUQsMkRBQThDO0FBQzlDLCtDQUE2QztBQUVyQyxJQUFBLHlCQUF5QixHQUFxQixxQkFBUSwwQkFBN0IsRUFBRSxjQUFjLEdBQUsscUJBQVEsZUFBYixDQUFjO0FBRS9ELG1CQUF5QixRQUFhO0lBQ3BDLElBQU0sT0FBTyxHQUFHLE9BQU8sUUFBUSxLQUFLLFFBQVEsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7SUFFL0YsSUFBSSxPQUFPLE9BQU8sS0FBSyxVQUFVLElBQUkseUJBQXlCLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUMzRixPQUFPLFFBQVEsQ0FBQztLQUNqQjtJQUNELElBQUksK0NBQWtCLENBQUMsT0FBTyxDQUFDLElBQUksY0FBYyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUNwRixPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUVELGtFQUFrRTtJQUNsRSxrQ0FBa0M7SUFDbEMsSUFDRSxPQUFPLEtBQUssUUFBUTtRQUNwQiwyQkFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDO1FBQzFDLDJCQUFlLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFDM0M7UUFDQSxPQUFPLDJCQUFlLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNwRDtJQUVELElBQUksWUFBa0MsQ0FB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dmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IG5nQ29uZmlnIGZyb20gJy4uL2NvbW1vbi9jb3JlLmNvbmZpZyc7XG5pbXBvcnQgeyBpc05nSW5qZWN0aW9uVG9rZW4gfSBmcm9tICcuLi9jb21tb24vZnVuYy5pcy1uZy1pbmplY3Rpb24tdG9rZW4nO1xuaW1wb3J0IG5nTW9ja3NVbml2ZXJzZSBmcm9tICcuLi9jb21tb24vbmctbW9ja3MtdW5pdmVyc2UnO1xuXG5pbXBvcnQgdXNlRmFjdG9yeSBmcm9tICcuL2hlbHBlci51c2UtZmFjdG9yeSc7XG5pbXBvcnQgeyBNb2NrU2VydmljZSB9IGZyb20gJy4vbW9jay1zZXJ2aWNlJztcblxuY29uc3QgeyBuZXZlck1vY2tQcm92aWRlZEZ1bmN0aW9uLCBuZXZlck1vY2tUb2tlbiB9ID0gbmdDb25maWc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChwcm92aWRlcjogYW55KTogUHJvdmlkZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCBwcm92aWRlID0gdHlwZW9mIHByb3ZpZGVyID09PSAnb2JqZWN0JyAmJiBwcm92aWRlci5wcm92aWRlID8gcHJvdmlkZXIucHJvdmlkZSA6IHByb3ZpZGVyO1xuXG4gIGlmICh0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXZlck1vY2tQcm92aWRlZEZ1bmN0aW9uLmluZGV4T2YocHJvdmlkZS5uYW1lKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgaWYgKGlzTmdJbmplY3Rpb25Ub2tlbihwcm92aWRlKSAmJiBuZXZlck1vY2tUb2tlbi5pbmRleE9mKHByb3ZpZGUudG9TdHJpbmcoKSkgIT09IC0xKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIE9ubHkgcHVyZSBwcm92aWRlcyBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIHRoZWlyIGluZmx1ZW5jZSBvblxuICAvLyBhbm90aGVyIGRpZmZlcmVudCBkZWNsYXJhdGlvbnMuXG4gIGlmIChcbiAgICBwcm92aWRlID09PSBwcm92aWRlciAmJlxuICAgIG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ2NhY2hlUHJvdmlkZXInKSAmJlxuICAgIG5nTW9ja3NVbml2ZXJzZS5jYWNoZVByb3ZpZGVycy5oYXMocHJvdmlkZSlcbiAgKSB7XG4gICAgcmV0dXJuIG5nTW9ja3NVbml2ZXJzZS5jYWNoZVByb3ZpZGVycy5nZXQocHJvdmlkZSk7XG4gIH1cblxuICBsZXQgbW9ja1Byb3ZpZGVyOiBQcm92aWRlciB8IHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbW9ja1Byb3ZpZGVyID0gdXNlRmFjdG9yeShwcm92aWRlLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IE1vY2tTZXJ2aWNlKHByb3ZpZGUpO1xuICAgICAgLy8gTWFnaWMgYmVsb3cgYWRkcyBtaXNzZWQgcHJvcGVydGllcyB0byB0aGUgaW5zdGFuY2UgdG9cbiAgICAgIC8vIGZ1bGZpbGwgbWlzc2VkIGFic3RyYWN0IG1ldGhvZHMuXG4gICAgICBpZiAocHJvdmlkZSAhPT0gcHJvdmlkZXIgJiYgT2JqZWN0LmtleXMocHJvdmlkZXIpLmluZGV4T2YoJ3VzZUNsYXNzJykgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5zdGFuY2UpO1xuICAgICAgICBjb25zdCBjaGlsZCA9IE1vY2tTZXJ2aWNlKHByb3ZpZGVyLnVzZUNsYXNzKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoaWxkKSkge1xuICAgICAgICAgIGlmIChleGlzdGluZy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRlZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2hpbGQsIG5hbWUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLCBuYW1lLCBkZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb3ZpZGUgPT09IHByb3ZpZGVyICYmIG1vY2tQcm92aWRlciAmJiBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdjYWNoZVByb3ZpZGVyJykpIHtcbiAgICBuZ01vY2tzVW5pdmVyc2UuY2FjaGVQcm92aWRlcnMuc2V0KHByb3ZpZGUsIG1vY2tQcm92aWRlcik7XG4gIH1cbiAgaWYgKG1vY2tQcm92aWRlcikge1xuICAgIHJldHVybiBtb2NrUHJvdmlkZXI7XG4gIH1cblxuICAvLyBOb3Qgc3VyZSBpZiB0aGlzIGNhc2UgaXMgcG9zc2libGUsIGFsbCBjbGFzc2VzIHNob3VsZCBiZSBhbHJlYWR5XG4gIC8vIHJlcGxhY2VkIHdpdGggdGhlaXIgbW9jayBjb3BsaWVzIGJ5IHRoZSBjb2RlIGFib3ZlLCBiZWxvdyB3ZVxuICAvLyBzaG91bGQgaGF2ZSBvbmx5IHRva2VucyBhbmQgc3RyaW5nIGxpdGVyYWxzIHdpdGggYSBwcm9wZXIgZGVmaW5pdGlvbi5cbiAgaWYgKHByb3ZpZGUgPT09IHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFRva2VucyBhcmUgc3BlY2lhbCBzdWJqZWN0LCB3ZSBjYW4gc2tpcCBhZGRpbmcgdGhlbSBiZWNhdXNlIGluIGEgbW9jayBtb2R1bGUgdGhleSBhcmUgdXNlbGVzcy5cbiAgLy8gVGhlIG1haW4gcHJvYmxlbSBpcyB0aGF0IHByb3ZpZGluZyB1bmRlZmluZWQgdG8gSFRUUF9JTlRFUkNFUFRPUlMgYW5kIG90aGVycyBicmVha3MgdGhlaXIgY29kZS5cbiAgLy8gSWYgYSB0ZXN0aW5nIG1vZHVsZSAvIGNvbXBvbmVudCByZXF1aXJlcyBvbWl0dGVkIHRva2VucyB0aGVuIHRoZXkgc2hvdWxkIGJlIHByb3ZpZGVkIG1hbnVhbGx5XG4gIC8vIGR1cmluZyBjcmVhdGlvbiBvZiBUZXN0QmVkIG1vZHVsZS5cbiAgaWYgKHByb3ZpZGVyLm11bHRpKSB7XG4gICAgaWYgKG5nTW9ja3NVbml2ZXJzZS5jb25maWcuaGFzKCdtdWx0aScpKSB7XG4gICAgICAobmdNb2Nrc1VuaXZlcnNlLmNvbmZpZy5nZXQoJ211bHRpJykgYXMgU2V0PGFueT4pLmFkZChwcm92aWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIGlmIGEgdG9rZW4gaGFzIGEgcHJpbWl0aXZlIHR5cGUsIHdlIGNhbiByZXR1cm4gaXRzIGluaXRpYWwgc3RhdGUuXG4gIGlmIChPYmplY3Qua2V5cyhwcm92aWRlcikuaW5kZXhPZigndXNlVmFsdWUnKSAhPT0gLTEpIHtcbiAgICBtb2NrUHJvdmlkZXIgPVxuICAgICAgcHJvdmlkZXIudXNlVmFsdWUgJiYgdHlwZW9mIHByb3ZpZGVyLnVzZVZhbHVlID09PSAnb2JqZWN0J1xuICAgICAgICA/IHVzZUZhY3RvcnkocHJvdmlkZSwgKCkgPT4gTW9ja1NlcnZpY2UocHJvdmlkZXIudXNlVmFsdWUpKVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHByb3ZpZGUsXG4gICAgICAgICAgICB1c2VWYWx1ZTpcbiAgICAgICAgICAgICAgdHlwZW9mIHByb3ZpZGVyLnVzZVZhbHVlID09PSAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgcHJvdmlkZXIudXNlVmFsdWUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgcHJvdmlkZXIudXNlVmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgIDogcHJvdmlkZXIudXNlVmFsdWUgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9O1xuICB9XG4gIGlmICghbW9ja1Byb3ZpZGVyICYmIE9iamVjdC5rZXlzKHByb3ZpZGVyKS5pbmRleE9mKCd1c2VFeGlzdGluZycpICE9PSAtMSkge1xuICAgIG1vY2tQcm92aWRlciA9IHByb3ZpZGVyO1xuICB9XG4gIGlmICghbW9ja1Byb3ZpZGVyICYmIE9iamVjdC5rZXlzKHByb3ZpZGVyKS5pbmRleE9mKCd1c2VDbGFzcycpICE9PSAtMSkge1xuICAgIG1vY2tQcm92aWRlciA9XG4gICAgICBuZ01vY2tzVW5pdmVyc2UuYnVpbHRQcm92aWRlcnMuaGFzKHByb3ZpZGVyLnVzZUNsYXNzKSAmJlxuICAgICAgbmdNb2Nrc1VuaXZlcnNlLmJ1aWx0UHJvdmlkZXJzLmdldChwcm92aWRlci51c2VDbGFzcykgPT09IHByb3ZpZGVyLnVzZUNsYXNzXG4gICAgICAgID8gcHJvdmlkZXJcbiAgICAgICAgOiB1c2VGYWN0b3J5KHByb3ZpZGUsICgpID0+IE1vY2tTZXJ2aWNlKHByb3ZpZGVyLnVzZUNsYXNzKSk7XG4gIH1cbiAgaWYgKCFtb2NrUHJvdmlkZXIgJiYgT2JqZWN0LmtleXMocHJvdmlkZXIpLmluZGV4T2YoJ3VzZUZhY3RvcnknKSAhPT0gLTEpIHtcbiAgICBtb2NrUHJvdmlkZXIgPSB1c2VGYWN0b3J5KHByb3ZpZGUsICgpID0+ICh7fSkpO1xuICB9XG5cbiAgcmV0dXJuIG1vY2tQcm92aWRlcjtcbn1cbiJdfQ==