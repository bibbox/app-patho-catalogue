"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockBuilder = void 0;
var testing_1 = require("@angular/core/testing");
var core_helpers_1 = require("../common/core.helpers");
var core_tokens_1 = require("../common/core.tokens");
var func_is_ng_def_1 = require("../common/func.is-ng-def");
var ng_mocks_universe_1 = require("../common/ng-mocks-universe");
var mock_helper_1 = require("../mock-helper/mock-helper");
var mock_builder_performance_1 = require("./mock-builder-performance");
/**
 * @see https://github.com/ike18t/ng-mocks#mockbuilder
 */
function MockBuilder(keepDeclaration, itsModuleToMock) {
    if (!testing_1.TestBed.ngMocks) {
        var configureTestingModule_1 = testing_1.TestBed.configureTestingModule;
        testing_1.TestBed.configureTestingModule = function (moduleDef) {
            var e_1, _a, e_2, _b;
            ng_mocks_universe_1.default.global.set('bullet:customized', true);
            var mocks;
            var overrides = new Map();
            try {
                for (var _c = __values(core_helpers_1.flatten(moduleDef.providers || [])), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var provide = _d.value;
                    if (typeof provide !== 'object') {
                        continue;
                    }
                    if (provide.provide === core_tokens_1.NG_MOCKS) {
                        mocks = provide.useValue;
                    }
                    if (provide.provide === core_tokens_1.NG_MOCKS_OVERRIDES) {
                        overrides = provide.useValue;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (mocks) {
                mock_helper_1.ngMocks.flushTestBed();
            }
            var testBed = configureTestingModule_1.call(testing_1.TestBed, moduleDef);
            if (!mocks) {
                return testBed;
            }
            /* istanbul ignore else */
            // Now we can apply overrides.
            if (!testing_1.TestBed.ngMocksOverrides) {
                testing_1.TestBed.ngMocksOverrides = new Set();
            }
            try {
                for (var _e = __values(core_helpers_1.mapEntries(overrides)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var _g = __read(_f.value, 2), def = _g[0], override = _g[1];
                    testing_1.TestBed.ngMocksOverrides.add(def);
                    /* istanbul ignore else */
                    if (func_is_ng_def_1.isNgDef(def, 'c')) {
                        testBed.overrideComponent(def, override);
                    }
                    else if (func_is_ng_def_1.isNgDef(def, 'd')) {
                        testBed.overrideDirective(def, override);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return testBed;
        };
        var resetTestingModule_1 = testing_1.TestBed.resetTestingModule;
        testing_1.TestBed.resetTestingModule = function () {
            var e_3, _a;
            if (ng_mocks_universe_1.default.global.has('bullet')) {
                if (ng_mocks_universe_1.default.global.has('bullet:customized')) {
                    ng_mocks_universe_1.default.global.set('bullet:reset', true);
                }
                return testing_1.TestBed;
            }
            ng_mocks_universe_1.default.global.delete('bullet:customized');
            ng_mocks_universe_1.default.global.delete('bullet:reset');
            // Thanks Ivy and its TestBed.override - it doesn't clean up leftovers.
            if (testing_1.TestBed.ngMocksOverrides) {
                mock_helper_1.ngMocks.flushTestBed();
                try {
                    for (var _b = __values(testing_1.TestBed.ngMocksOverrides), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var def = _c.value;
                        /* istanbul ignore else */
                        if (func_is_ng_def_1.isNgDef(def, 'c')) {
                            testing_1.TestBed.overrideComponent(def, {});
                        }
                        else if (func_is_ng_def_1.isNgDef(def, 'd')) {
                            testing_1.TestBed.overrideDirective(def, {});
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                testing_1.TestBed.ngMocksOverrides = undefined;
            }
            return resetTestingModule_1.call(testing_1.TestBed);
        };
        testing_1.TestBed.ngMocks = true;
    }
    var instance = new mock_builder_performance_1.MockBuilderPerformance();
    if (keepDeclaration) {
        instance.keep(keepDeclaration, {
            export: true,
        });
    }
    if (itsModuleToMock) {
        instance.mock(itsModuleToMock, {
            exportAll: true,
        });
    }
    return instance;
}
exports.MockBuilder = MockBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1idWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL21vY2stYnVpbGRlci9tb2NrLWJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsaURBQXNGO0FBRXRGLHVEQUE2RDtBQUM3RCxxREFBcUU7QUFFckUsMkRBQW1EO0FBQ25ELGlFQUEwRDtBQUMxRCwwREFBcUQ7QUFFckQsdUVBQW9FO0FBR3BFOztHQUVHO0FBQ0gsU0FBZ0IsV0FBVyxDQUN6QixlQUF1RSxFQUN2RSxlQUFpRDtJQUVqRCxJQUFJLENBQUUsaUJBQWUsQ0FBQyxPQUFPLEVBQUU7UUFDN0IsSUFBTSx3QkFBc0IsR0FBRyxpQkFBTyxDQUFDLHNCQUFzQixDQUFDO1FBQzlELGlCQUFPLENBQUMsc0JBQXNCLEdBQUcsVUFBQyxTQUE2Qjs7WUFDN0QsMkJBQWUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3RELElBQUksS0FBZ0MsQ0FBQztZQUNyQyxJQUFJLFNBQVMsR0FBNkMsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7Z0JBRXBFLEtBQXNCLElBQUEsS0FBQSxTQUFBLHNCQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUMsQ0FBQSxnQkFBQSw0QkFBRTtvQkFBckQsSUFBTSxPQUFPLFdBQUE7b0JBQ2hCLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO3dCQUMvQixTQUFTO3FCQUNWO29CQUNELElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxzQkFBUSxFQUFFO3dCQUNoQyxLQUFLLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztxQkFDMUI7b0JBQ0QsSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLGdDQUFrQixFQUFFO3dCQUMxQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztxQkFDOUI7aUJBQ0Y7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QUFJLENBQUMsZUFBZSxFQUFFO1lBQzdCLE1BQU0sRUFBRSxJQUFJO1NBQ2IsQ0FBQyxDQUFDO0tBQ0o7SUFDRCxJQUFJLGVBQWUsRUFBRTtRQUNuQixRQUFRLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUM3QixTQUFTLEVBQUUsSUFBSTtTQUNoQixDQUFDLENBQUM7S0FDSjtJQUNELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUE3RkQsa0NBNkZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1ldGFkYXRhT3ZlcnJpZGUsIFRlc3RCZWQsIFRlc3RNb2R1bGVNZXRhZGF0YSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvdGVzdGluZyc7XG5cbmltcG9ydCB7IGZsYXR0ZW4sIG1hcEVudHJpZXMgfSBmcm9tICcuLi9jb21tb24vY29yZS5oZWxwZXJzJztcbmltcG9ydCB7IE5HX01PQ0tTLCBOR19NT0NLU19PVkVSUklERVMgfSBmcm9tICcuLi9jb21tb24vY29yZS50b2tlbnMnO1xuaW1wb3J0IHsgQW55VHlwZSB9IGZyb20gJy4uL2NvbW1vbi9jb3JlLnR5cGVzJztcbmltcG9ydCB7IGlzTmdEZWYgfSBmcm9tICcuLi9jb21tb24vZnVuYy5pcy1uZy1kZWYnO1xuaW1wb3J0IG5nTW9ja3NVbml2ZXJzZSBmcm9tICcuLi9jb21tb24vbmctbW9ja3MtdW5pdmVyc2UnO1xuaW1wb3J0IHsgbmdNb2NrcyB9IGZyb20gJy4uL21vY2staGVscGVyL21vY2staGVscGVyJztcblxuaW1wb3J0IHsgTW9ja0J1aWxkZXJQZXJmb3JtYW5jZSB9IGZyb20gJy4vbW9jay1idWlsZGVyLXBlcmZvcm1hbmNlJztcbmltcG9ydCB7IElNb2NrQnVpbGRlciB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2lrZTE4dC9uZy1tb2NrcyNtb2NrYnVpbGRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gTW9ja0J1aWxkZXIoXG4gIGtlZXBEZWNsYXJhdGlvbj86IEFueVR5cGU8YW55PiB8IEluamVjdGlvblRva2VuPGFueT4gfCBudWxsIHwgdW5kZWZpbmVkLFxuICBpdHNNb2R1bGVUb01vY2s/OiBBbnlUeXBlPGFueT4gfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBJTW9ja0J1aWxkZXIge1xuICBpZiAoIShUZXN0QmVkIGFzIGFueSkubmdNb2Nrcykge1xuICAgIGNvbnN0IGNvbmZpZ3VyZVRlc3RpbmdNb2R1bGUgPSBUZXN0QmVkLmNvbmZpZ3VyZVRlc3RpbmdNb2R1bGU7XG4gICAgVGVzdEJlZC5jb25maWd1cmVUZXN0aW5nTW9kdWxlID0gKG1vZHVsZURlZjogVGVzdE1vZHVsZU1ldGFkYXRhKSA9PiB7XG4gICAgICBuZ01vY2tzVW5pdmVyc2UuZ2xvYmFsLnNldCgnYnVsbGV0OmN1c3RvbWl6ZWQnLCB0cnVlKTtcbiAgICAgIGxldCBtb2NrczogTWFwPGFueSwgYW55PiB8IHVuZGVmaW5lZDtcbiAgICAgIGxldCBvdmVycmlkZXM6IE1hcDxBbnlUeXBlPGFueT4sIE1ldGFkYXRhT3ZlcnJpZGU8YW55Pj4gPSBuZXcgTWFwKCk7XG5cbiAgICAgIGZvciAoY29uc3QgcHJvdmlkZSBvZiBmbGF0dGVuKG1vZHVsZURlZi5wcm92aWRlcnMgfHwgW10pKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZS5wcm92aWRlID09PSBOR19NT0NLUykge1xuICAgICAgICAgIG1vY2tzID0gcHJvdmlkZS51c2VWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZS5wcm92aWRlID09PSBOR19NT0NLU19PVkVSUklERVMpIHtcbiAgICAgICAgICBvdmVycmlkZXMgPSBwcm92aWRlLnVzZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2Nrcykge1xuICAgICAgICBuZ01vY2tzLmZsdXNoVGVzdEJlZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVzdEJlZCA9IGNvbmZpZ3VyZVRlc3RpbmdNb2R1bGUuY2FsbChUZXN0QmVkLCBtb2R1bGVEZWYpO1xuICAgICAgaWYgKCFtb2Nrcykge1xuICAgICAgICByZXR1cm4gdGVzdEJlZDtcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIC8vIE5vdyB3ZSBjYW4gYXBwbHkgb3ZlcnJpZGVzLlxuICAgICAgaWYgKCEoVGVzdEJlZCBhcyBhbnkpLm5nTW9ja3NPdmVycmlkZXMpIHtcbiAgICAgICAgKFRlc3RCZWQgYXMgYW55KS5uZ01vY2tzT3ZlcnJpZGVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbZGVmLCBvdmVycmlkZV0gb2YgbWFwRW50cmllcyhvdmVycmlkZXMpKSB7XG4gICAgICAgIChUZXN0QmVkIGFzIGFueSkubmdNb2Nrc092ZXJyaWRlcy5hZGQoZGVmKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzTmdEZWYoZGVmLCAnYycpKSB7XG4gICAgICAgICAgdGVzdEJlZC5vdmVycmlkZUNvbXBvbmVudChkZWYsIG92ZXJyaWRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc05nRGVmKGRlZiwgJ2QnKSkge1xuICAgICAgICAgIHRlc3RCZWQub3ZlcnJpZGVEaXJlY3RpdmUoZGVmLCBvdmVycmlkZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRlc3RCZWQ7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc2V0VGVzdGluZ01vZHVsZSA9IFRlc3RCZWQucmVzZXRUZXN0aW5nTW9kdWxlO1xuICAgIChUZXN0QmVkIGFzIGFueSkucmVzZXRUZXN0aW5nTW9kdWxlID0gKCkgPT4ge1xuICAgICAgaWYgKG5nTW9ja3NVbml2ZXJzZS5nbG9iYWwuaGFzKCdidWxsZXQnKSkge1xuICAgICAgICBpZiAobmdNb2Nrc1VuaXZlcnNlLmdsb2JhbC5oYXMoJ2J1bGxldDpjdXN0b21pemVkJykpIHtcbiAgICAgICAgICBuZ01vY2tzVW5pdmVyc2UuZ2xvYmFsLnNldCgnYnVsbGV0OnJlc2V0JywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRlc3RCZWQ7XG4gICAgICB9XG4gICAgICBuZ01vY2tzVW5pdmVyc2UuZ2xvYmFsLmRlbGV0ZSgnYnVsbGV0OmN1c3RvbWl6ZWQnKTtcbiAgICAgIG5nTW9ja3NVbml2ZXJzZS5nbG9iYWwuZGVsZXRlKCdidWxsZXQ6cmVzZXQnKTtcblxuICAgICAgLy8gVGhhbmtzIEl2eSBhbmQgaXRzIFRlc3RCZWQub3ZlcnJpZGUgLSBpdCBkb2Vzbid0IGNsZWFuIHVwIGxlZnRvdmVycy5cbiAgICAgIGlmICgoVGVzdEJlZCBhcyBhbnkpLm5nTW9ja3NPdmVycmlkZXMpIHtcbiAgICAgICAgbmdNb2Nrcy5mbHVzaFRlc3RCZWQoKTtcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgKFRlc3RCZWQgYXMgYW55KS5uZ01vY2tzT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoaXNOZ0RlZihkZWYsICdjJykpIHtcbiAgICAgICAgICAgIFRlc3RCZWQub3ZlcnJpZGVDb21wb25lbnQoZGVmLCB7fSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc05nRGVmKGRlZiwgJ2QnKSkge1xuICAgICAgICAgICAgVGVzdEJlZC5vdmVycmlkZURpcmVjdGl2ZShkZWYsIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKFRlc3RCZWQgYXMgYW55KS5uZ01vY2tzT3ZlcnJpZGVzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzZXRUZXN0aW5nTW9kdWxlLmNhbGwoVGVzdEJlZCk7XG4gICAgfTtcblxuICAgIChUZXN0QmVkIGFzIGFueSkubmdNb2NrcyA9IHRydWU7XG4gIH1cblxuICBjb25zdCBpbnN0YW5jZSA9IG5ldyBNb2NrQnVpbGRlclBlcmZvcm1hbmNlKCk7XG5cbiAgaWYgKGtlZXBEZWNsYXJhdGlvbikge1xuICAgIGluc3RhbmNlLmtlZXAoa2VlcERlY2xhcmF0aW9uLCB7XG4gICAgICBleHBvcnQ6IHRydWUsXG4gICAgfSk7XG4gIH1cbiAgaWYgKGl0c01vZHVsZVRvTW9jaykge1xuICAgIGluc3RhbmNlLm1vY2soaXRzTW9kdWxlVG9Nb2NrLCB7XG4gICAgICBleHBvcnRBbGw6IHRydWUsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuIl19