"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var testing_1 = require("@angular/core/testing");
var ng_mocks_universe_1 = require("../common/ng-mocks-universe");
var mock_helper_flushTestBed_1 = require("./mock-helper.flushTestBed");
exports.default = (function () {
    beforeAll(function () {
        if (ng_mocks_universe_1.default.global.has('bullet:customized')) {
            testing_1.TestBed.resetTestingModule();
        }
        ng_mocks_universe_1.default.global.set('bullet', true);
    });
    afterEach(function () {
        var e_1, _a;
        mock_helper_flushTestBed_1.default();
        try {
            for (var _b = __values(testing_1.getTestBed()._activeFixtures || /* istanbul ignore next */ []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var fixture = _c.value;
                fixture.destroy();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
    afterAll(function () {
        ng_mocks_universe_1.default.global.delete('bullet');
        if (ng_mocks_universe_1.default.global.has('bullet:reset')) {
            testing_1.TestBed.resetTestingModule();
        }
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1oZWxwZXIuZmFzdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL21vY2staGVscGVyL21vY2staGVscGVyLmZhc3Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsaURBQTREO0FBRTVELGlFQUEwRDtBQUUxRCx1RUFBc0Q7QUFFdEQsbUJBQWU7SUFDYixTQUFTLENBQUM7UUFDUixJQUFJLDJCQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO1lBQ25ELGlCQUFPLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztTQUM5QjtRQUNELDJCQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDN0MsQ0FBQyxDQUFDLENBQUM7SUFFSCxTQUFTLENBQUM7O1FBQ1Isa0NBQVksRUFBRSxDQUFDOztZQUNmLEtBQXNCLElBQUEsS0FBQSxTQUFDLG9CQUFVLEVBQVUsQ0FBQyxlQUFlLElBQUksMEJBQTBCLENBQUMsRUFBRSxDQUFBLGdCQUFBLDRCQUFFO2dCQUF6RixJQUFNLE9BQU8sV0FBQTtnQkFDaEIsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQ25COzs7Ozs7Ozs7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQztRQUNQLDJCQUFlLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN4QyxJQUFJLDJCQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUM5QyxpQkFBTyxDQUFDLGtCQUFrQixFQUFFLENBQUM7U0FDOUI7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsRUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFRlc3RCZWQsIFRlc3RCZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3Rlc3RpbmcnO1xuXG5pbXBvcnQgbmdNb2Nrc1VuaXZlcnNlIGZyb20gJy4uL2NvbW1vbi9uZy1tb2Nrcy11bml2ZXJzZSc7XG5cbmltcG9ydCBmbHVzaFRlc3RCZWQgZnJvbSAnLi9tb2NrLWhlbHBlci5mbHVzaFRlc3RCZWQnO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIGJlZm9yZUFsbCgoKSA9PiB7XG4gICAgaWYgKG5nTW9ja3NVbml2ZXJzZS5nbG9iYWwuaGFzKCdidWxsZXQ6Y3VzdG9taXplZCcpKSB7XG4gICAgICBUZXN0QmVkLnJlc2V0VGVzdGluZ01vZHVsZSgpO1xuICAgIH1cbiAgICBuZ01vY2tzVW5pdmVyc2UuZ2xvYmFsLnNldCgnYnVsbGV0JywgdHJ1ZSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgZmx1c2hUZXN0QmVkKCk7XG4gICAgZm9yIChjb25zdCBmaXh0dXJlIG9mIChnZXRUZXN0QmVkKCkgYXMgYW55KS5fYWN0aXZlRml4dHVyZXMgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW10pIHtcbiAgICAgIGZpeHR1cmUuZGVzdHJveSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgYWZ0ZXJBbGwoKCkgPT4ge1xuICAgIG5nTW9ja3NVbml2ZXJzZS5nbG9iYWwuZGVsZXRlKCdidWxsZXQnKTtcbiAgICBpZiAobmdNb2Nrc1VuaXZlcnNlLmdsb2JhbC5oYXMoJ2J1bGxldDpyZXNldCcpKSB7XG4gICAgICBUZXN0QmVkLnJlc2V0VGVzdGluZ01vZHVsZSgpO1xuICAgIH1cbiAgfSk7XG59O1xuIl19