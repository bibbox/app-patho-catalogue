import { Location } from '@angular/common';
import { Injectable } from '@angular/core';
import { NavigationEnd, Router } from '@angular/router';
import { delay, filter, map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "@angular/common";
/**
 * Track Route changes for applications using Angular's
 * default router
 *
 * @link https://angular.io/api/router/Router
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from '@angular/common';
export class AngularRouterTracking {
    constructor(router, location) {
        this.router = router;
        this.location = location;
    }
    trackLocation(settings) {
        return this.router.events.pipe(filter(e => e instanceof NavigationEnd), filter(() => !settings.developerMode), map((e) => {
            return { url: e.urlAfterRedirects };
        }), delay(0));
    }
    prepareExternalUrl(url) {
        return this.location.prepareExternalUrl(url);
    }
}
AngularRouterTracking.ɵfac = function AngularRouterTracking_Factory(t) { return new (t || AngularRouterTracking)(ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(ɵngcc2.Location)); };
AngularRouterTracking.ɵprov = i0.ɵɵdefineInjectable({ factory: function AngularRouterTracking_Factory() { return new AngularRouterTracking(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.Location)); }, token: AngularRouterTracking, providedIn: "root" });
AngularRouterTracking.ctorParameters = () => [
    { type: Router },
    { type: Location }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularRouterTracking, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc1.Router }, { type: ɵngcc2.Location }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1yb3V0ZXIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvY29yZS9hbmd1bGFyLXJvdXRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXhELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3BEO0FBRUM7QUFBdUM7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7Ozs7QUFFSCxNQUFNLE9BQU8scUJBQXFCO0FBQUcsSUFDbkMsWUFDVSxNQUFjLEVBQ2QsUUFBa0I7QUFDNUIsUUFGVSxXQUFNLEdBQU4sTUFBTSxDQUFRO0FBQUMsUUFDZixhQUFRLEdBQVIsUUFBUSxDQUFVO0FBQUMsSUFDMUIsQ0FBQztBQUNOLElBQ0UsYUFBYSxDQUFDLFFBQVE7QUFBSSxRQUN4QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDNUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLGFBQWEsQ0FBQyxFQUN2QyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEVBQ3JDLEdBQUcsQ0FBQyxDQUFDLENBQWdCLEVBQUUsRUFBRTtBQUMvQixZQUFRLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLENBQUM7QUFDNUMsUUFBTSxDQUFDLENBQUMsRUFDRixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQ1QsQ0FBQztBQUNOLElBQUUsQ0FBQztBQUNILElBQ0Usa0JBQWtCLENBQUMsR0FBVztBQUFJLFFBQ2hDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNqRCxJQUFFLENBQUM7QUFDSDtzTEFBQztBQUNELHFQQXJCSztBQUFDO0VBREwsVUFBVSxTQUFDLHJCQUN5QyxZQWQ3QixNQUFNO0NBYWhCLFVBQVUsRUFBRSxNQUFNLEVBQUUsckJBYkEsWUFGekIsUUFBUTtBQUFHOzs7O2tHQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uRW5kLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5pbXBvcnQgeyBkZWxheSwgZmlsdGVyLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFJvdXRlcmxlc3NUcmFja2luZywgVHJhY2tOYXZpZ2F0aW9uRW5kIH0gZnJvbSAnLi9yb3V0ZXJsZXNzJztcblxuLyoqXG4gKiBUcmFjayBSb3V0ZSBjaGFuZ2VzIGZvciBhcHBsaWNhdGlvbnMgdXNpbmcgQW5ndWxhcidzXG4gKiBkZWZhdWx0IHJvdXRlclxuICpcbiAqIEBsaW5rIGh0dHBzOi8vYW5ndWxhci5pby9hcGkvcm91dGVyL1JvdXRlclxuICovXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJSb3V0ZXJUcmFja2luZyBpbXBsZW1lbnRzIFJvdXRlcmxlc3NUcmFja2luZyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsXG4gICAgcHJpdmF0ZSBsb2NhdGlvbjogTG9jYXRpb24sXG4gICkge31cblxuICB0cmFja0xvY2F0aW9uKHNldHRpbmdzKTogT2JzZXJ2YWJsZTxUcmFja05hdmlnYXRpb25FbmQ+IHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgICBmaWx0ZXIoZSA9PiBlIGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCksXG4gICAgICBmaWx0ZXIoKCkgPT4gIXNldHRpbmdzLmRldmVsb3Blck1vZGUpLFxuICAgICAgbWFwKChlOiBOYXZpZ2F0aW9uRW5kKSA9PiB7XG4gICAgICAgIHJldHVybiB7IHVybDogZS51cmxBZnRlclJlZGlyZWN0cyB9O1xuICAgICAgfSksXG4gICAgICBkZWxheSgwKSxcbiAgICApO1xuICB9XG5cbiAgcHJlcGFyZUV4dGVybmFsVXJsKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5wcmVwYXJlRXh0ZXJuYWxVcmwodXJsKTtcbiAgfVxufVxuIl19