import { __decorate, __param } from "tslib";
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { ScrollToAnimation } from './scroll-to-animation';
import { DEFAULTS, isElementRef, isNativeElement, isNumber, isString, isWindow, stripHash } from './scroll-to-helpers';
import { ReplaySubject, throwError } from 'rxjs';
/**
 * The Scroll To Service handles starting, interrupting
 * and ending the actual Scroll Animation. It provides
 * some utilities to find the proper HTML Element on a
 * given page to setup Event Listeners and calculate
 * distances for the Animation.
 */
import * as Éµngcc0 from '@angular/core';
let ScrollToService = class ScrollToService {
    /**
     * Construct and setup required paratemeters.
     *
     * @param document         A Reference to the Document
     * @param platformId       Angular Platform ID
     */
    constructor(document, platformId) {
        this.document = document;
        this.platformId = platformId;
        this.interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];
    }
    /**
     * Target an Element to scroll to. Notice that the `TimeOut` decorator
     * ensures the executing to take place in the next Angular lifecycle.
     * This allows for scrolling to elements that are e.g. initially hidden
     * by means of `*ngIf`, but ought to be scrolled to eventually.
     *
     * @todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     *  - https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param options         Configuration Object
     * @returns               Observable
     */
    scrollTo(options) {
        if (!isPlatformBrowser(this.platformId)) {
            return new ReplaySubject().asObservable();
        }
        return this.start(options);
    }
    /**
     * Start a new Animation.
     *
     * @todo Emit proper events from subscription
     *
     * @param options         Configuration Object
     * @returns               Observable
     */
    start(options) {
        // Merge config with default values
        const mergedConfigOptions = Object.assign(Object.assign({}, DEFAULTS), options);
        if (this.animation) {
            this.animation.stop();
        }
        const targetNode = this.getNode(mergedConfigOptions.target);
        if (mergedConfigOptions.target && !targetNode) {
            return throwError('Unable to find Target Element');
        }
        const container = this.getContainer(mergedConfigOptions, targetNode);
        if (mergedConfigOptions.container && !container) {
            return throwError('Unable to find Container Element');
        }
        const listenerTarget = this.getListenerTarget(container) || window;
        let to = container ? container.getBoundingClientRect().top : 0;
        if (targetNode) {
            to = isWindow(listenerTarget) ?
                window.scrollY + targetNode.getBoundingClientRect().top :
                targetNode.getBoundingClientRect().top;
        }
        // Create Animation
        this.animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this.platformId));
        const onInterrupt = () => this.animation.stop();
        this.addInterruptiveEventListeners(listenerTarget, onInterrupt);
        // Start Animation
        const animation$ = this.animation.start();
        this.subscribeToAnimation(animation$, listenerTarget, onInterrupt);
        return animation$;
    }
    /**
     * Subscribe to the events emitted from the Scrolling
     * Animation. Events might be used for e.g. unsubscribing
     * once finished.
     *
     * @param animation$              The Animation Observable
     * @param listenerTarget          The Listener Target for events
     * @param onInterrupt             The handler for Interruptive Events
     * @returns                       Void
     */
    subscribeToAnimation(animation$, listenerTarget, onInterrupt) {
        const subscription = animation$
            .subscribe(() => {
        }, () => {
        }, () => {
            this.removeInterruptiveEventListeners(this.interruptiveEvents, listenerTarget, onInterrupt);
            subscription.unsubscribe();
        });
    }
    /**
     * Get the container HTML Element in which
     * the scrolling should happen.
     *
     * @param options         The Merged Configuration Object
     * @param targetNode    the targeted HTMLElement
     */
    getContainer(options, targetNode) {
        let container = null;
        if (options.container) {
            container = this.getNode(options.container, true);
        }
        else if (targetNode) {
            container = this.getFirstScrollableParent(targetNode);
        }
        return container;
    }
    /**
     * Add listeners for the Animation Interruptive Events
     * to the Listener Target.
     *
     * @param events            List of events to listen to
     * @param listenerTarget    Target to attach the listener on
     * @param handler           Handler for when the listener fires
     * @returns                 Void
     */
    addInterruptiveEventListeners(listenerTarget, handler) {
        if (!listenerTarget) {
            listenerTarget = window;
        }
        this.interruptiveEvents
            .forEach(event => listenerTarget
            .addEventListener(event, handler, this.supportPassive() ? { passive: true } : false));
    }
    /**
     * Feature-detect support for passive event listeners.
     *
     * @returns       Whether or not passive event listeners are supported
     */
    supportPassive() {
        let supportsPassive = false;
        try {
            const opts = Object.defineProperty({}, 'passive', {
                get: () => {
                    supportsPassive = true;
                }
            });
            window.addEventListener('testPassive', null, opts);
            window.removeEventListener('testPassive', null, opts);
        }
        catch (e) {
        }
        return supportsPassive;
    }
    /**
     * Remove listeners for the Animation Interrupt Event from
     * the Listener Target. Specifying the correct handler prevents
     * memory leaks and makes the allocated memory available for
     * Garbage Collection.
     *
     * @param events            List of Interruptive Events to remove
     * @param listenerTarget    Target to attach the listener on
     * @param handler           Handler for when the listener fires
     * @returns                 Void
     */
    removeInterruptiveEventListeners(events, listenerTarget, handler) {
        if (!listenerTarget) {
            listenerTarget = window;
        }
        events.forEach(event => listenerTarget.removeEventListener(event, handler));
    }
    /**
     * Find the first scrollable parent Node of a given
     * Element. The DOM Tree gets searched upwards
     * to find this first scrollable parent. Parents might
     * be ignored by CSS styles applied to the HTML Element.
     *
     * @param nativeElement     The Element to search the DOM Tree upwards from
     * @returns                 The first scrollable parent HTML Element
     */
    getFirstScrollableParent(nativeElement) {
        let style = window.getComputedStyle(nativeElement);
        const overflowRegex = /(auto|scroll|overlay)/;
        if (style.position === 'fixed') {
            return null;
        }
        let parent = nativeElement;
        while (parent.parentElement) {
            parent = parent.parentElement;
            style = window.getComputedStyle(parent);
            if (style.position === 'absolute'
                || style.overflow === 'hidden'
                || style.overflowY === 'hidden') {
                continue;
            }
            if (overflowRegex.test(style.overflow + style.overflowY)
                || parent.tagName === 'BODY') {
                return parent;
            }
        }
        return null;
    }
    /**
     * Get the Target Node to scroll to.
     *
     * @param id              The given ID of the node, either a string or
     *                        an element reference
     * @param allowBodyTag    Indicate whether or not the Document Body is
     *                        considered a valid Target Node
     * @returns               The Target Node to scroll to
     */
    getNode(id, allowBodyTag = false) {
        let targetNode;
        if (isString(id)) {
            if (allowBodyTag && (id === 'body' || id === 'BODY')) {
                targetNode = this.document.body;
            }
            else {
                targetNode = this.document.getElementById(stripHash(id));
            }
        }
        else if (isNumber(id)) {
            targetNode = this.document.getElementById(String(id));
        }
        else if (isElementRef(id)) {
            targetNode = id.nativeElement;
        }
        else if (isNativeElement(id)) {
            targetNode = id;
        }
        return targetNode;
    }
    /**
     * Retrieve the Listener target. This Listener Target is used
     * to attach Event Listeners on. In case of the target being
     * the Document Body, we need the actual `window` to listen
     * for events.
     *
     * @param container           The HTML Container element
     * @returns                   The Listener Target to attach events on
     */
    getListenerTarget(container) {
        if (!container) {
            return null;
        }
        return this.isDocumentBody(container) ? window : container;
    }
    /**
     * Test if a given HTML Element is the Document Body.
     *
     * @param element             The given HTML Element
     * @returns                   Whether or not the Element is the
     *                            Document Body Element
     */
    isDocumentBody(element) {
        return element.tagName.toUpperCase() === 'BODY';
    }
};
ScrollToService.Éµfac = function ScrollToService_Factory(t) { return new (t || ScrollToService)(Éµngcc0.ÉµÉµinject(DOCUMENT), Éµngcc0.ÉµÉµinject(PLATFORM_ID)); };
ScrollToService.Éµprov = Éµngcc0.ÉµÉµdefineInjectable({ token: ScrollToService, factory: function (t) { return ScrollToService.Éµfac(t); } });
ScrollToService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
ScrollToService = __decorate([ __param(0, Inject(DOCUMENT)),
    __param(1, Inject(PLATFORM_ID))
], ScrollToService);
/*@__PURE__*/ (function () { Éµngcc0.ÉµsetClassMetadata(ScrollToService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, null); })();
export { ScrollToService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLXRvLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIkBuaWNreS1sZW5hZXJzL25neC1zY3JvbGwtdG8vbGliL3Njcm9sbC10by5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEUsT0FBTyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRzlELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzFELE9BQU8sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLGVBQWUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2SCxPQUFPLEVBQWMsYUFBYSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILElBQWEsZUFBZSxHQUE1QixNQUFhLGVBQWU7QUFDNUIsSUFnQkU7QUFDRjtBQUNFO0FBQ0U7QUFDRTtBQUVKLE9BREc7QUFDTCxJQUFFLFlBQzRCLFFBQWEsRUFDVixVQUFlO0FBQzdDLFFBRjJCLGFBQVEsR0FBUixRQUFRLENBQUs7QUFBQyxRQUNYLGVBQVUsR0FBVixVQUFVLENBQUs7QUFDaEQsUUFDSSxJQUFJLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFDN0UsSUFBRSxDQUFDO0FBQ0gsSUFDRTtBQUNGO0FBQ0U7QUFDRTtBQUNFO0FBRUg7QUFBTztBQUNFO0FBRUg7QUFBTztBQUNFO0FBRUosT0FEVDtBQUNMLElBQUUsUUFBUSxDQUFDLE9BQThCO0FBQUksUUFFekMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFB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QztBQUNILElBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFDRTtBQUNFO0FBRUosT0FEQztBQUNMLElBQVUsY0FBYyxDQUFDLE9BQW9CO0FBQUksUUFDN0MsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLE1BQU0sQ0FBQztBQUNwRCxJQUFFLENBQUM7QUFDSCxDQUFDOzt5SUFBQTtBQUNEO0FBQXlDLDRDQXpTcEMsTUFBTSxTQUFDLFFBQVE7QUFBUyw0Q0FDeEIsTUFBTSxTQUFDLFdBQVc7QUFBUTtBQXpCbEIsZUFBZSxvQkFEM0IsVUFBVSxFQUFFLGpCQUNULENBd0JDLFdBQUEsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBQUUsSUFDbEIsV0FBQSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7QUFBQyxHQXpCWixlQUFlLENBZ1UzQjs7Ozs7Ozs7O2tDQUNEO0FBQUMsU0FqVVksZUFBZTtBQUU1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERPQ1VNRU5ULCBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IFNjcm9sbFRvQ29uZmlnT3B0aW9ucywgU2Nyb2xsVG9Db25maWdPcHRpb25zVGFyZ2V0LCBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LCBTY3JvbGxUb1RhcmdldCB9IGZyb20gJy4vc2Nyb2xsLXRvLWNvbmZpZy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2Nyb2xsVG9BbmltYXRpb24gfSBmcm9tICcuL3Njcm9sbC10by1hbmltYXRpb24nO1xuaW1wb3J0IHsgREVGQVVMVFMsIGlzRWxlbWVudFJlZiwgaXNOYXRpdmVFbGVtZW50LCBpc051bWJlciwgaXNTdHJpbmcsIGlzV2luZG93LCBzdHJpcEhhc2ggfSBmcm9tICcuL3Njcm9sbC10by1oZWxwZXJzJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcblxuLyoqXG4gKiBUaGUgU2Nyb2xsIFRvIFNlcnZpY2UgaGFuZGxlcyBzdGFydGluZywgaW50ZXJydXB0aW5nXG4gKiBhbmQgZW5kaW5nIHRoZSBhY3R1YWwgU2Nyb2xsIEFuaW1hdGlvbi4gSXQgcHJvdmlkZXNcbiAqIHNvbWUgdXRpbGl0aWVzIHRvIGZpbmQgdGhlIHByb3BlciBIVE1MIEVsZW1lbnQgb24gYVxuICogZ2l2ZW4gcGFnZSB0byBzZXR1cCBFdmVudCBMaXN0ZW5lcnMgYW5kIGNhbGN1bGF0ZVxuICogZGlzdGFuY2VzIGZvciB0aGUgQW5pbWF0aW9uLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2Nyb2xsVG9TZXJ2aWNlIHtcblxuICAvKipcbiAgICogVGhlIGFuaW1hdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBzY3JvbGxpbmdcbiAgICogdG8gaGFwcGVuIHNtb290aGx5IG92ZXIgdGltZS4gRGVmaW5pbmcgaXQgaGVyZVxuICAgKiBhbGxvd3MgZm9yIHVzYWdlIG9mIGUuZy4gYHN0YXJ0YCBhbmQgYHN0b3BgXG4gICAqIG1ldGhvZHMgd2l0aGluIHRoaXMgQW5ndWxhciBTZXJ2aWNlLlxuICAgKi9cbiAgcHJpdmF0ZSBhbmltYXRpb246IFNjcm9sbFRvQW5pbWF0aW9uO1xuXG4gIC8qKlxuICAgKiBJbnRlcnJ1cHRpdmUgRXZlbnRzIGFsbG93IHRvIHNjcm9sbGluZyBhbmltYXRpb25cbiAgICogdG8gYmUgaW50ZXJydXB0ZWQgYmVmb3JlIGl0IGlzIGZpbmlzaGVkLiBUaGUgbGlzdFxuICAgKiBvZiBJbnRlcnJ1cHRpdmUgRXZlbnRzIHJlcHJlc2VudHMgdGhvc2UuXG4gICAqL1xuICBwcml2YXRlIGludGVycnVwdGl2ZUV2ZW50czogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbmQgc2V0dXAgcmVxdWlyZWQgcGFyYXRlbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gZG9jdW1lbnQgICAgICAgICBBIFJlZmVyZW5jZSB0byB0aGUgRG9jdW1lbnRcbiAgICogQHBhcmFtIHBsYXRmb3JtSWQgICAgICAgQW5ndWxhciBQbGF0Zm9ybSBJRFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBkb2N1bWVudDogYW55LFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogYW55XG4gICkge1xuICAgIHRoaXMuaW50ZXJydXB0aXZlRXZlbnRzID0gWydtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ3RvdWNoc3RhcnQnXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYXJnZXQgYW4gRWxlbWVudCB0byBzY3JvbGwgdG8uIE5vdGljZSB0aGF0IHRoZSBgVGltZU91dGAgZGVjb3JhdG9yXG4gICAqIGVuc3VyZXMgdGhlIGV4ZWN1dGluZyB0byB0YWtlIHBsYWNlIGluIHRoZSBuZXh0IEFuZ3VsYXIgbGlmZWN5Y2xlLlxuICAgKiBUaGlzIGFsbG93cyBmb3Igc2Nyb2xsaW5nIHRvIGVsZW1lbnRzIHRoYXQgYXJlIGUuZy4gaW5pdGlhbGx5IGhpZGRlblxuICAgKiBieSBtZWFucyBvZiBgKm5nSWZgLCBidXQgb3VnaHQgdG8gYmUgc2Nyb2xsZWQgdG8gZXZlbnR1YWxseS5cbiAgICpcbiAgICogQHRvZG8gdHlwZSAnYW55JyBpbiBPYnNlcnZhYmxlIHNob3VsZCBiZWNvbWUgY3VzdG9tIHR5cGUgbGlrZSAnU2Nyb2xsVG9FdmVudCcgKGJhc2UgY2xhc3MpLCBzZWUgaXNzdWUgY29tbWVudDpcbiAgICogIC0gaHR0cHM6Ly9naXRodWIuY29tL25pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9pc3N1ZXMvMTAjaXNzdWVjb21tZW50LTMxNzE5ODQ4MVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAgICAgICAgIENvbmZpZ3VyYXRpb24gT2JqZWN0XG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgT2JzZXJ2YWJsZVxuICAgKi9cbiAgc2Nyb2xsVG8ob3B0aW9uczogU2Nyb2xsVG9Db25maWdPcHRpb25zKTogT2JzZXJ2YWJsZTxhbnk+IHtcblxuICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXBsYXlTdWJqZWN0KCkuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhcnQob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgQW5pbWF0aW9uLlxuICAgKlxuICAgKiBAdG9kbyBFbWl0IHByb3BlciBldmVudHMgZnJvbSBzdWJzY3JpcHRpb25cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgICAgICAgICBDb25maWd1cmF0aW9uIE9iamVjdFxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIE9ic2VydmFibGVcbiAgICovXG4gIHByaXZhdGUgc3RhcnQob3B0aW9uczogU2Nyb2xsVG9Db25maWdPcHRpb25zKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcblxuICAgIC8vIE1lcmdlIGNvbmZpZyB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgY29uc3QgbWVyZ2VkQ29uZmlnT3B0aW9ucyA9IHtcbiAgICAgIC4uLkRFRkFVTFRTIGFzIFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9IGFzIFNjcm9sbFRvQ29uZmlnT3B0aW9uc1RhcmdldDtcblxuICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgdGhpcy5hbmltYXRpb24uc3RvcCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLmdldE5vZGUobWVyZ2VkQ29uZmlnT3B0aW9ucy50YXJnZXQpO1xuICAgIGlmIChtZXJnZWRDb25maWdPcHRpb25zLnRhcmdldCAmJiAhdGFyZ2V0Tm9kZSkge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IoJ1VuYWJsZSB0byBmaW5kIFRhcmdldCBFbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbmVyOiBIVE1MRWxlbWVudCA9IHRoaXMuZ2V0Q29udGFpbmVyKG1lcmdlZENvbmZpZ09wdGlvbnMsIHRhcmdldE5vZGUpO1xuICAgIGlmIChtZXJnZWRDb25maWdPcHRpb25zLmNvbnRhaW5lciAmJiAhY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcignVW5hYmxlIHRvIGZpbmQgQ29udGFpbmVyIEVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lclRhcmdldCA9IHRoaXMuZ2V0TGlzdGVuZXJUYXJnZXQoY29udGFpbmVyKSB8fCB3aW5kb3c7XG5cbiAgICBsZXQgdG8gPSBjb250YWluZXIgPyBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcblxuICAgIGlmICh0YXJnZXROb2RlKSB7XG4gICAgICB0byA9IGlzV2luZG93KGxpc3RlbmVyVGFyZ2V0KSA/XG4gICAgICAgIHdpbmRvdy5zY3JvbGxZICsgdGFyZ2V0Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgOlxuICAgICAgICB0YXJnZXROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgQW5pbWF0aW9uXG4gICAgdGhpcy5hbmltYXRpb24gPSBuZXcgU2Nyb2xsVG9BbmltYXRpb24oXG4gICAgICBjb250YWluZXIsXG4gICAgICBsaXN0ZW5lclRhcmdldCxcbiAgICAgIGlzV2luZG93KGxpc3RlbmVyVGFyZ2V0KSxcbiAgICAgIHRvLFxuICAgICAgbWVyZ2VkQ29uZmlnT3B0aW9ucyxcbiAgICAgIGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZClcbiAgICApO1xuICAgIGNvbnN0IG9uSW50ZXJydXB0ID0gKCkgPT4gdGhpcy5hbmltYXRpb24uc3RvcCgpO1xuICAgIHRoaXMuYWRkSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnMobGlzdGVuZXJUYXJnZXQsIG9uSW50ZXJydXB0KTtcblxuICAgIC8vIFN0YXJ0IEFuaW1hdGlvblxuICAgIGNvbnN0IGFuaW1hdGlvbiQgPSB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuICAgIHRoaXMuc3Vic2NyaWJlVG9BbmltYXRpb24oYW5pbWF0aW9uJCwgbGlzdGVuZXJUYXJnZXQsIG9uSW50ZXJydXB0KTtcblxuICAgIHJldHVybiBhbmltYXRpb24kO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgZXZlbnRzIGVtaXR0ZWQgZnJvbSB0aGUgU2Nyb2xsaW5nXG4gICAqIEFuaW1hdGlvbi4gRXZlbnRzIG1pZ2h0IGJlIHVzZWQgZm9yIGUuZy4gdW5zdWJzY3JpYmluZ1xuICAgKiBvbmNlIGZpbmlzaGVkLlxuICAgKlxuICAgKiBAcGFyYW0gYW5pbWF0aW9uJCAgICAgICAgICAgICAgVGhlIEFuaW1hdGlvbiBPYnNlcnZhYmxlXG4gICAqIEBwYXJhbSBsaXN0ZW5lclRhcmdldCAgICAgICAgICBUaGUgTGlzdGVuZXIgVGFyZ2V0IGZvciBldmVudHNcbiAgICogQHBhcmFtIG9uSW50ZXJydXB0ICAgICAgICAgICAgIFRoZSBoYW5kbGVyIGZvciBJbnRlcnJ1cHRpdmUgRXZlbnRzXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICAgICAgICBWb2lkXG4gICAqL1xuICBwcml2YXRlIHN1YnNjcmliZVRvQW5pbWF0aW9uKFxuICAgIGFuaW1hdGlvbiQ6IE9ic2VydmFibGU8YW55PixcbiAgICBsaXN0ZW5lclRhcmdldDogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcbiAgICBvbkludGVycnVwdDogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdFxuICApIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhbmltYXRpb24kXG4gICAgICAuc3Vic2NyaWJlKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnModGhpcy5pbnRlcnJ1cHRpdmVFdmVudHMsIGxpc3RlbmVyVGFyZ2V0LCBvbkludGVycnVwdCk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb250YWluZXIgSFRNTCBFbGVtZW50IGluIHdoaWNoXG4gICAqIHRoZSBzY3JvbGxpbmcgc2hvdWxkIGhhcHBlbi5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgICAgICAgICBUaGUgTWVyZ2VkIENvbmZpZ3VyYXRpb24gT2JqZWN0XG4gICAqIEBwYXJhbSB0YXJnZXROb2RlICAgIHRoZSB0YXJnZXRlZCBIVE1MRWxlbWVudFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRDb250YWluZXIob3B0aW9uczogU2Nyb2xsVG9Db25maWdPcHRpb25zLCB0YXJnZXROb2RlOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG5cbiAgICBsZXQgY29udGFpbmVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMuY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSB0aGlzLmdldE5vZGUob3B0aW9ucy5jb250YWluZXIsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Tm9kZSkge1xuICAgICAgY29udGFpbmVyID0gdGhpcy5nZXRGaXJzdFNjcm9sbGFibGVQYXJlbnQodGFyZ2V0Tm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbGlzdGVuZXJzIGZvciB0aGUgQW5pbWF0aW9uIEludGVycnVwdGl2ZSBFdmVudHNcbiAgICogdG8gdGhlIExpc3RlbmVyIFRhcmdldC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50cyAgICAgICAgICAgIExpc3Qgb2YgZXZlbnRzIHRvIGxpc3RlbiB0b1xuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgVGFyZ2V0IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgb25cbiAgICogQHBhcmFtIGhhbmRsZXIgICAgICAgICAgIEhhbmRsZXIgZm9yIHdoZW4gdGhlIGxpc3RlbmVyIGZpcmVzXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICBWb2lkXG4gICAqL1xuICBwcml2YXRlIGFkZEludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKFxuICAgIGxpc3RlbmVyVGFyZ2V0OiBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LFxuICAgIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpOiB2b2lkIHtcblxuICAgIGlmICghbGlzdGVuZXJUYXJnZXQpIHtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0ID0gd2luZG93O1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJydXB0aXZlRXZlbnRzXG4gICAgICAuZm9yRWFjaChldmVudCA9PiBsaXN0ZW5lclRhcmdldFxuICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdGhpcy5zdXBwb3J0UGFzc2l2ZSgpID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2UpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZWF0dXJlLWRldGVjdCBzdXBwb3J0IGZvciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHJldHVybnMgICAgICAgV2hldGhlciBvciBub3QgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMgYXJlIHN1cHBvcnRlZFxuICAgKi9cbiAgcHJpdmF0ZSBzdXBwb3J0UGFzc2l2ZSgpOiBib29sZWFuIHtcblxuICAgIGxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgZm9yIHRoZSBBbmltYXRpb24gSW50ZXJydXB0IEV2ZW50IGZyb21cbiAgICogdGhlIExpc3RlbmVyIFRhcmdldC4gU3BlY2lmeWluZyB0aGUgY29ycmVjdCBoYW5kbGVyIHByZXZlbnRzXG4gICAqIG1lbW9yeSBsZWFrcyBhbmQgbWFrZXMgdGhlIGFsbG9jYXRlZCBtZW1vcnkgYXZhaWxhYmxlIGZvclxuICAgKiBHYXJiYWdlIENvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBldmVudHMgICAgICAgICAgICBMaXN0IG9mIEludGVycnVwdGl2ZSBFdmVudHMgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSBsaXN0ZW5lclRhcmdldCAgICBUYXJnZXQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciBvblxuICAgKiBAcGFyYW0gaGFuZGxlciAgICAgICAgICAgSGFuZGxlciBmb3Igd2hlbiB0aGUgbGlzdGVuZXIgZmlyZXNcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgIFZvaWRcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnMoXG4gICAgZXZlbnRzOiBzdHJpbmdbXSxcbiAgICBsaXN0ZW5lclRhcmdldDogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcbiAgICBoYW5kbGVyOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTogdm9pZCB7XG5cbiAgICBpZiAoIWxpc3RlbmVyVGFyZ2V0KSB7XG4gICAgICBsaXN0ZW5lclRhcmdldCA9IHdpbmRvdztcbiAgICB9XG4gICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGZpcnN0IHNjcm9sbGFibGUgcGFyZW50IE5vZGUgb2YgYSBnaXZlblxuICAgKiBFbGVtZW50LiBUaGUgRE9NIFRyZWUgZ2V0cyBzZWFyY2hlZCB1cHdhcmRzXG4gICAqIHRvIGZpbmQgdGhpcyBmaXJzdCBzY3JvbGxhYmxlIHBhcmVudC4gUGFyZW50cyBtaWdodFxuICAgKiBiZSBpZ25vcmVkIGJ5IENTUyBzdHlsZXMgYXBwbGllZCB0byB0aGUgSFRNTCBFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gbmF0aXZlRWxlbWVudCAgICAgVGhlIEVsZW1lbnQgdG8gc2VhcmNoIHRoZSBET00gVHJlZSB1cHdhcmRzIGZyb21cbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgIFRoZSBmaXJzdCBzY3JvbGxhYmxlIHBhcmVudCBIVE1MIEVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgZ2V0Rmlyc3RTY3JvbGxhYmxlUGFyZW50KG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xuXG4gICAgbGV0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobmF0aXZlRWxlbWVudCk7XG5cbiAgICBjb25zdCBvdmVyZmxvd1JlZ2V4OiBSZWdFeHAgPSAvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLztcblxuICAgIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHBhcmVudCA9IG5hdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKHBhcmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcblxuICAgICAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnXG4gICAgICAgIHx8IHN0eWxlLm92ZXJmbG93ID09PSAnaGlkZGVuJ1xuICAgICAgICB8fCBzdHlsZS5vdmVyZmxvd1kgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcmZsb3dSZWdleC50ZXN0KHN0eWxlLm92ZXJmbG93ICsgc3R5bGUub3ZlcmZsb3dZKVxuICAgICAgICB8fCBwYXJlbnQudGFnTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBUYXJnZXQgTm9kZSB0byBzY3JvbGwgdG8uXG4gICAqXG4gICAqIEBwYXJhbSBpZCAgICAgICAgICAgICAgVGhlIGdpdmVuIElEIG9mIHRoZSBub2RlLCBlaXRoZXIgYSBzdHJpbmcgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBhbiBlbGVtZW50IHJlZmVyZW5jZVxuICAgKiBAcGFyYW0gYWxsb3dCb2R5VGFnICAgIEluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBEb2N1bWVudCBCb2R5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgY29uc2lkZXJlZCBhIHZhbGlkIFRhcmdldCBOb2RlXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgVGhlIFRhcmdldCBOb2RlIHRvIHNjcm9sbCB0b1xuICAgKi9cbiAgcHJpdmF0ZSBnZXROb2RlKGlkOiBTY3JvbGxUb1RhcmdldCwgYWxsb3dCb2R5VGFnOiBib29sZWFuID0gZmFsc2UpOiBIVE1MRWxlbWVudCB7XG5cbiAgICBsZXQgdGFyZ2V0Tm9kZTogSFRNTEVsZW1lbnQ7XG5cbiAgICBpZiAoaXNTdHJpbmcoaWQpKSB7XG4gICAgICBpZiAoYWxsb3dCb2R5VGFnICYmIChpZCA9PT0gJ2JvZHknIHx8IGlkID09PSAnQk9EWScpKSB7XG4gICAgICAgIHRhcmdldE5vZGUgPSB0aGlzLmRvY3VtZW50LmJvZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXROb2RlID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHJpcEhhc2goaWQpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlkKSkge1xuICAgICAgdGFyZ2V0Tm9kZSA9IHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoU3RyaW5nKGlkKSk7XG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnRSZWYoaWQpKSB7XG4gICAgICB0YXJnZXROb2RlID0gaWQubmF0aXZlRWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKGlzTmF0aXZlRWxlbWVudChpZCkpIHtcbiAgICAgIHRhcmdldE5vZGUgPSBpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Tm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgTGlzdGVuZXIgdGFyZ2V0LiBUaGlzIExpc3RlbmVyIFRhcmdldCBpcyB1c2VkXG4gICAqIHRvIGF0dGFjaCBFdmVudCBMaXN0ZW5lcnMgb24uIEluIGNhc2Ugb2YgdGhlIHRhcmdldCBiZWluZ1xuICAgKiB0aGUgRG9jdW1lbnQgQm9keSwgd2UgbmVlZCB0aGUgYWN0dWFsIGB3aW5kb3dgIHRvIGxpc3RlblxuICAgKiBmb3IgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gY29udGFpbmVyICAgICAgICAgICBUaGUgSFRNTCBDb250YWluZXIgZWxlbWVudFxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgICBUaGUgTGlzdGVuZXIgVGFyZ2V0IHRvIGF0dGFjaCBldmVudHMgb25cbiAgICovXG4gIHByaXZhdGUgZ2V0TGlzdGVuZXJUYXJnZXQoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQge1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNEb2N1bWVudEJvZHkoY29udGFpbmVyKSA/IHdpbmRvdyA6IGNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIGEgZ2l2ZW4gSFRNTCBFbGVtZW50IGlzIHRoZSBEb2N1bWVudCBCb2R5LlxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAgICAgICAgICAgICBUaGUgZ2l2ZW4gSFRNTCBFbGVtZW50XG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBFbGVtZW50IGlzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEb2N1bWVudCBCb2R5IEVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgaXNEb2N1bWVudEJvZHkoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBlbGVtZW50IGlzIEhUTUxCb2R5RWxlbWVudCB7XG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWSc7XG4gIH1cbn1cbiJdfQ==