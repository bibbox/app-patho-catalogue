"use strict";
/*
 * @PatrickJS
 */
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var rxjs_1 = require("rxjs");
/*
 * token to requestIdleCallback
 */
exports.REQUEST_IDLE_CALLBACK = new core_1.InjectionToken('REQUEST_IDLE_CALLBACK');
/*
 * Private API.
 * please use @angularclass/request-idle-callback if you want
 * to use `__requestIdle` this without providers
 */
function __requestIdle(zone) {
    if (typeof window === 'undefined') {
        return function (fn) { return setTimeout(fn); };
    }
    var win = window;
    if (win.requestIdleCallback) {
        return function (fn) { return win.requestIdleCallback(fn); };
    }
    return function (fn) { return zone.runOutsideAngular(function () { return win.setTimeout(fn, 10); }); };
}
exports.__requestIdle = __requestIdle;
var ɵngcc0 = require('@angular/core');
var IdlePreload = /** @class */ (function () {
    /*
     * include zone to run outside of zone.js
     */
    function IdlePreload(_ngZone, requestIdleCallback) {
        this._ngZone = _ngZone;
        this.requestIdleCallback = requestIdleCallback;
    }
    /*
     * fire off preloading async modules
     */
    IdlePreload.prototype.preload = function (route, fn /* () => Observable<any>*/) {
        this.requestIdleCallback(fn);
        return rxjs_1.of(null);
    };
    /** @nocollapse */
    IdlePreload.ctorParameters = function () { return [
        { type: core_1.NgZone },
        { type: undefined, decorators: [{ type: core_1.Inject, args: [exports.REQUEST_IDLE_CALLBACK,] }] }
    ]; };
IdlePreload.ɵfac = function IdlePreload_Factory(t) { return new (t || IdlePreload)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(exports.REQUEST_IDLE_CALLBACK)); };
IdlePreload.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IdlePreload, factory: function (t) { return IdlePreload.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IdlePreload, [{
        type: core_1.Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: core_1.Inject,
                args: [exports.REQUEST_IDLE_CALLBACK]
            }] }]; }, null); })();
    return IdlePreload;
}());
exports.IdlePreload = IdlePreload;
/*
 * raw providers
 */
exports.IDLE_PRELOAD_PROVIDERS = [
    { provide: IdlePreload, useClass: IdlePreload, deps: [core_1.NgZone, exports.REQUEST_IDLE_CALLBACK] }
];
exports.REQUEST_IDLE_CALLBACK_PROVIDERS = [
    { provide: exports.REQUEST_IDLE_CALLBACK, useFactory: __requestIdle, deps: [core_1.NgZone] }
];
var IdlePreloadModule = /** @class */ (function () {
    function IdlePreloadModule() {
    }
    /*
     * forRoot() to allow providers only be created once
     */
    IdlePreloadModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: IdlePreloadModule,
            providers: (config.requestIdleCallback === false ? [] : exports.REQUEST_IDLE_CALLBACK_PROVIDERS).concat(exports.IDLE_PRELOAD_PROVIDERS)
        };
    };
    /*
     * alias for reference to IdlePreload token
     */
    IdlePreloadModule.IdleStrategy = function () {
        return IdlePreload;
    };
IdlePreloadModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IdlePreloadModule });
IdlePreloadModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IdlePreloadModule_Factory(t) { return new (t || IdlePreloadModule)(); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IdlePreloadModule, [{
        type: core_1.NgModule,
        args: [{
            // because Angular
            }]
    }], function () { return []; }, null); })();
    return IdlePreloadModule;
}());
exports.IdlePreloadModule = IdlePreloadModule;

//# sourceMappingURL=index.js.map