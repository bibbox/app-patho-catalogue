import { Injectable, Inject, Optional } from "@angular/core";
import { Validators, NG_VALIDATORS, NG_ASYNC_VALIDATORS } from "@angular/forms";
import { DynamicFormHook } from "../model/misc/dynamic-form-control-validation.model";
import { isObject, isString } from "../utils/core.utils";
import { DYNAMIC_VALIDATORS } from "./dynamic-form-validators";
import { DEFAULT_ERROR_STATE_MATCHER, DYNAMIC_ERROR_MESSAGES_MATCHER } from "./dynamic-form-validation-matchers";
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "./dynamic-form-validators";
import * as i3 from "./dynamic-form-validation-matchers";
import * as ɵngcc0 from '@angular/core';
export class DynamicFormValidationService {
    constructor(_NG_VALIDATORS, _NG_ASYNC_VALIDATORS, _DYNAMIC_VALIDATORS, _DYNAMIC_ERROR_MESSAGES_MATCHER) {
        this._NG_VALIDATORS = _NG_VALIDATORS;
        this._NG_ASYNC_VALIDATORS = _NG_ASYNC_VALIDATORS;
        this._DYNAMIC_VALIDATORS = _DYNAMIC_VALIDATORS;
        this._DYNAMIC_ERROR_MESSAGES_MATCHER = _DYNAMIC_ERROR_MESSAGES_MATCHER;
    }
    getValidatorFn(validatorName, validatorArgs = null, validatorsToken = this._NG_VALIDATORS) {
        let validatorFn;
        if (Validators.hasOwnProperty(validatorName)) { // Built-in Angular Validators
            validatorFn = Validators[validatorName];
        }
        else { // Custom Validators
            if (this._DYNAMIC_VALIDATORS && this._DYNAMIC_VALIDATORS.has(validatorName)) {
                validatorFn = this._DYNAMIC_VALIDATORS.get(validatorName);
            }
            else if (validatorsToken) {
                validatorFn = validatorsToken.find(validator => validator.name === validatorName);
            }
        }
        if (validatorFn === undefined) { // throw when no validator could be resolved
            throw new Error(`validator "${validatorName}" is not provided via NG_VALIDATORS, NG_ASYNC_VALIDATORS or DYNAMIC_FORM_VALIDATORS`);
        }
        if (validatorArgs !== null) {
            return validatorFn(validatorArgs);
        }
        return validatorFn;
    }
    getValidatorFns(validatorsConfig, validatorsToken = this._NG_VALIDATORS) {
        let validatorFns = [];
        if (isObject(validatorsConfig)) {
            validatorFns = Object.keys(validatorsConfig).map(validatorConfigKey => {
                const validatorConfigValue = validatorsConfig[validatorConfigKey];
                if (this.isValidatorDescriptor(validatorConfigValue)) {
                    const descriptor = validatorConfigValue;
                    return this.getValidatorFn(descriptor.name, descriptor.args, validatorsToken);
                }
                return this.getValidatorFn(validatorConfigKey, validatorConfigValue, validatorsToken);
            });
        }
        return validatorFns;
    }
    getValidator(validatorName, validatorArgs = null) {
        return this.getValidatorFn(validatorName, validatorArgs);
    }
    getAsyncValidator(validatorName, validatorArgs = null) {
        return this.getValidatorFn(validatorName, validatorArgs, this._NG_ASYNC_VALIDATORS);
    }
    getValidators(validatorsConfig) {
        return this.getValidatorFns(validatorsConfig);
    }
    getAsyncValidators(asyncValidatorsConfig) {
        return this.getValidatorFns(asyncValidatorsConfig, this._NG_ASYNC_VALIDATORS);
    }
    updateValidators(validatorsConfig, control, model) {
        model.validators = validatorsConfig;
        if (validatorsConfig === null) {
            control.clearValidators();
        }
        else {
            control.setValidators(this.getValidators(validatorsConfig));
        }
        control.updateValueAndValidity();
    }
    updateAsyncValidators(asyncValidatorsConfig, control, model) {
        model.asyncValidators = asyncValidatorsConfig;
        if (asyncValidatorsConfig === null) {
            control.clearAsyncValidators();
        }
        else {
            control.setAsyncValidators(this.getAsyncValidators(asyncValidatorsConfig));
        }
        control.updateValueAndValidity();
    }
    showErrorMessages(control, model, hasFocus) {
        const precondition = control.invalid && model.hasErrorMessages;
        const matcher = this._DYNAMIC_ERROR_MESSAGES_MATCHER ? this._DYNAMIC_ERROR_MESSAGES_MATCHER(control, model, hasFocus) :
            DEFAULT_ERROR_STATE_MATCHER(control, model, hasFocus);
        return precondition && matcher;
    }
    parseErrorMessageConfig(template, model, error = null) {
        return template.replace(/{{\s*(.+?)\s*}}/mg, (_match, expression) => {
            let propertySource = model;
            let propertyName = expression;
            if (expression.indexOf("validator.") >= 0 && error) {
                propertySource = error;
                propertyName = expression.replace("validator.", "");
            }
            return propertySource[propertyName] !== null && propertySource[propertyName] !== undefined ?
                propertySource[propertyName] : null;
        });
    }
    createErrorMessages(control, model) {
        const messages = [];
        if (model.hasErrorMessages) {
            const messagesConfig = model.errorMessages;
            Object.keys(control.errors || {}).forEach(validationErrorKey => {
                let messageKey = validationErrorKey;
                if (validationErrorKey === "minlength" || validationErrorKey === "maxlength") {
                    messageKey = messageKey.replace("length", "Length");
                }
                if (messagesConfig.hasOwnProperty(messageKey)) {
                    const validationError = control.getError(validationErrorKey);
                    const messageTemplate = messagesConfig[messageKey];
                    messages.push(this.parseErrorMessageConfig(messageTemplate, model, validationError));
                }
            });
        }
        return messages;
    }
    isFormHook(value) {
        return isString(value) && Object.values(DynamicFormHook).includes(value);
    }
    isValidatorDescriptor(value) {
        if (isObject(value)) {
            return value.hasOwnProperty("name") && value.hasOwnProperty("args");
        }
        return false;
    }
}
DynamicFormValidationService.ɵfac = function DynamicFormValidationService_Factory(t) { return new (t || DynamicFormValidationService)(ɵngcc0.ɵɵinject(NG_VALIDATORS, 8), ɵngcc0.ɵɵinject(NG_ASYNC_VALIDATORS, 8), ɵngcc0.ɵɵinject(DYNAMIC_VALIDATORS, 8), ɵngcc0.ɵɵinject(DYNAMIC_ERROR_MESSAGES_MATCHER, 8)); };
DynamicFormValidationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DynamicFormValidationService_Factory() { return new DynamicFormValidationService(i0.ɵɵinject(i1.NG_VALIDATORS, 8), i0.ɵɵinject(i1.NG_ASYNC_VALIDATORS, 8), i0.ɵɵinject(i2.DYNAMIC_VALIDATORS, 8), i0.ɵɵinject(i3.DYNAMIC_ERROR_MESSAGES_MATCHER, 8)); }, token: DynamicFormValidationService, providedIn: "root" });
DynamicFormValidationService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [NG_VALIDATORS,] }] },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [NG_ASYNC_VALIDATORS,] }] },
    { type: Map, decorators: [{ type: Optional }, { type: Inject, args: [DYNAMIC_VALIDATORS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DYNAMIC_ERROR_MESSAGES_MATCHER,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DynamicFormValidationService, [{
        type: Injectable,
        args: [{
                providedIn: "root"
            }]
    }], function () { return [{ type: Array, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NG_VALIDATORS]
            }] }, { type: Array, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NG_ASYNC_VALIDATORS]
            }] }, { type: Map, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DYNAMIC_VALIDATORS]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DYNAMIC_ERROR_MESSAGES_MATCHER]
            }] }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1mb3JtLXZhbGlkYXRpb24uc2VydmljZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctZHluYW1pYy1mb3Jtcy9jb3JlL3NyYy9saWIvc2VydmljZS9keW5hbWljLWZvcm0tdmFsaWRhdGlvbi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3RCxPQUFPLEVBSUgsVUFBVSxFQUNWLGFBQWEsRUFDYixtQkFBbUIsRUFDdEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQ0gsZUFBZSxFQUdsQixNQUFNLHFEQUFxRCxDQUFDO0FBQzdELE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDekQsT0FBTyxFQUFFLGtCQUFrQixFQUFnRCxNQUFNLDJCQUEyQixDQUFDO0FBQzdHLE9BQU8sRUFDSCwyQkFBMkIsRUFDM0IsOEJBQThCLEVBRWpDLE1BQU0sb0NBQW9DLENBQUM7QUFDNUM7QUFFc0I7QUFFWTtBQUVJOztBQUZ0QyxNQUFNLE9BQU8sNEJBQTRCO0FBQ3pDLElBQ0ksWUFBdUQsY0FBNkIsRUFDdkIsb0JBQXdDLEVBQ3pDLG1CQUE4RCxFQUNsRCwrQkFBNEQ7QUFDeEksUUFKMkQsbUJBQWMsR0FBZCxjQUFjLENBQWU7QUFBQyxRQUN4Qix5QkFBb0IsR0FBcEIsb0JBQW9CLENBQW9CO0FBQUMsUUFDMUMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUEyQztBQUFDLFFBQ25ELG9DQUErQixHQUEvQiwrQkFBK0IsQ0FBNkI7QUFBQyxJQUNySSxDQUFDO0FBQ0wsSUFDWSxjQUFjLENBQUMsYUFBcUIsRUFBRSxnQkFBcUIsSUFBSSxFQUNoRCxrQkFBbUMsSUFBSSxDQUFDLGNBQWM7QUFBSSxRQUU3RSxJQUFJLFdBQXFELENBQUM7QUFDbEUsUUFDUSxJ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T0FBTyxLQUFLLENBQUM7QUFDckIsSUFBSSxDQUFDO0FBQ0w7aVRBQUM7QUFDRCxtWUFyTEs7QUFBQztFQUhMLFVBQVUsU0FBQyxrQkFDUixVQUFVLEVBQUUsTUFBTSxjQUNyQix2RUFHYyx3Q0FBRSxRQUFRLFlBQUksTUFBTSxTQUFDLGFBQWE7QUFBUyx3Q0FDekMsUUFBUSxZQUFJLE1BQU0sU0FBQyxtQkFBbUI7QUFBUyxZQUNxQixHQUFHLHVCQUF2RSxRQUFRLFlBQUksTUFBTSxTQUFDLGtCQUFrQjtBQUFTLDRDQUM5QyxRQUFRLFlBQUksTUFBTSxTQUFDLDhCQUE4QjtBQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0LCBPcHRpb25hbCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQge1xuICAgIEFic3RyYWN0Q29udHJvbCxcbiAgICBBc3luY1ZhbGlkYXRvckZuLFxuICAgIFZhbGlkYXRvckZuLFxuICAgIFZhbGlkYXRvcnMsXG4gICAgTkdfVkFMSURBVE9SUyxcbiAgICBOR19BU1lOQ19WQUxJREFUT1JTXG59IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHsgRHluYW1pY0Zvcm1Db250cm9sTW9kZWwgfSBmcm9tIFwiLi4vbW9kZWwvZHluYW1pYy1mb3JtLWNvbnRyb2wubW9kZWxcIjtcbmltcG9ydCB7XG4gICAgRHluYW1pY0Zvcm1Ib29rLFxuICAgIER5bmFtaWNWYWxpZGF0b3JEZXNjcmlwdG9yLFxuICAgIER5bmFtaWNWYWxpZGF0b3JzQ29uZmlnXG59IGZyb20gXCIuLi9tb2RlbC9taXNjL2R5bmFtaWMtZm9ybS1jb250cm9sLXZhbGlkYXRpb24ubW9kZWxcIjtcbmltcG9ydCB7IGlzT2JqZWN0LCBpc1N0cmluZyB9IGZyb20gXCIuLi91dGlscy9jb3JlLnV0aWxzXCI7XG5pbXBvcnQgeyBEWU5BTUlDX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRmFjdG9yeSwgVmFsaWRhdG9yc1Rva2VuIH0gZnJvbSBcIi4vZHluYW1pYy1mb3JtLXZhbGlkYXRvcnNcIjtcbmltcG9ydCB7XG4gICAgREVGQVVMVF9FUlJPUl9TVEFURV9NQVRDSEVSLFxuICAgIERZTkFNSUNfRVJST1JfTUVTU0FHRVNfTUFUQ0hFUixcbiAgICBEeW5hbWljRXJyb3JNZXNzYWdlc01hdGNoZXJcbn0gZnJvbSBcIi4vZHluYW1pYy1mb3JtLXZhbGlkYXRpb24tbWF0Y2hlcnNcIjtcblxuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46IFwicm9vdFwiXG59KVxuZXhwb3J0IGNsYXNzIER5bmFtaWNGb3JtVmFsaWRhdGlvblNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChOR19WQUxJREFUT1JTKSBwcml2YXRlIF9OR19WQUxJREFUT1JTOiBWYWxpZGF0b3JGbltdLFxuICAgICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTkdfQVNZTkNfVkFMSURBVE9SUykgcHJpdmF0ZSBfTkdfQVNZTkNfVkFMSURBVE9SUzogQXN5bmNWYWxpZGF0b3JGbltdLFxuICAgICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRFlOQU1JQ19WQUxJREFUT1JTKSBwcml2YXRlIF9EWU5BTUlDX1ZBTElEQVRPUlM6IE1hcDxzdHJpbmcsIFZhbGlkYXRvciB8IFZhbGlkYXRvckZhY3Rvcnk+LFxuICAgICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRFlOQU1JQ19FUlJPUl9NRVNTQUdFU19NQVRDSEVSKSBwcml2YXRlIF9EWU5BTUlDX0VSUk9SX01FU1NBR0VTX01BVENIRVI6IER5bmFtaWNFcnJvck1lc3NhZ2VzTWF0Y2hlcikge1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VmFsaWRhdG9yRm4odmFsaWRhdG9yTmFtZTogc3RyaW5nLCB2YWxpZGF0b3JBcmdzOiBhbnkgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yc1Rva2VuOiBWYWxpZGF0b3JzVG9rZW4gPSB0aGlzLl9OR19WQUxJREFUT1JTKTogVmFsaWRhdG9yIHwgbmV2ZXIge1xuXG4gICAgICAgIGxldCB2YWxpZGF0b3JGbjogVmFsaWRhdG9yRmFjdG9yeSB8IFZhbGlkYXRvciB8IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoVmFsaWRhdG9ycy5oYXNPd25Qcm9wZXJ0eSh2YWxpZGF0b3JOYW1lKSkgeyAvLyBCdWlsdC1pbiBBbmd1bGFyIFZhbGlkYXRvcnNcblxuICAgICAgICAgICAgdmFsaWRhdG9yRm4gPSAoVmFsaWRhdG9ycyBhcyBhbnkpW3ZhbGlkYXRvck5hbWVdO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIEN1c3RvbSBWYWxpZGF0b3JzXG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9EWU5BTUlDX1ZBTElEQVRPUlMgJiYgdGhpcy5fRFlOQU1JQ19WQUxJREFUT1JTLmhhcyh2YWxpZGF0b3JOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvckZuID0gdGhpcy5fRFlOQU1JQ19WQUxJREFUT1JTLmdldCh2YWxpZGF0b3JOYW1lKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWxpZGF0b3JzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JGbiA9IHZhbGlkYXRvcnNUb2tlbi5maW5kKHZhbGlkYXRvciA9PiB2YWxpZGF0b3IubmFtZSA9PT0gdmFsaWRhdG9yTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWRhdG9yRm4gPT09IHVuZGVmaW5lZCkgeyAvLyB0aHJvdyB3aGVuIG5vIHZhbGlkYXRvciBjb3VsZCBiZSByZXNvbHZlZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGB2YWxpZGF0b3IgXCIke3ZhbGlkYXRvck5hbWV9XCIgaXMgbm90IHByb3ZpZGVkIHZpYSBOR19WQUxJREFUT1JTLCBOR19BU1lOQ19WQUxJREFUT1JTIG9yIERZTkFNSUNfRk9STV9WQUxJREFUT1JTYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWRhdG9yQXJncyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWxpZGF0b3JGbiBhcyBWYWxpZGF0b3JGYWN0b3J5KSh2YWxpZGF0b3JBcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JGbiBhcyBWYWxpZGF0b3I7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRWYWxpZGF0b3JGbnModmFsaWRhdG9yc0NvbmZpZzogRHluYW1pY1ZhbGlkYXRvcnNDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yc1Rva2VuOiBWYWxpZGF0b3JzVG9rZW4gPSB0aGlzLl9OR19WQUxJREFUT1JTKTogVmFsaWRhdG9yW10ge1xuXG4gICAgICAgIGxldCB2YWxpZGF0b3JGbnM6IFZhbGlkYXRvcltdID0gW107XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbGlkYXRvcnNDb25maWcpKSB7XG5cbiAgICAgICAgICAgIHZhbGlkYXRvckZucyA9IE9iamVjdC5rZXlzKHZhbGlkYXRvcnNDb25maWcpLm1hcCh2YWxpZGF0b3JDb25maWdLZXkgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9yQ29uZmlnVmFsdWUgPSAodmFsaWRhdG9yc0NvbmZpZyBhcyBEeW5hbWljVmFsaWRhdG9yc0NvbmZpZylbdmFsaWRhdG9yQ29uZmlnS2V5XTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRhdG9yRGVzY3JpcHRvcih2YWxpZGF0b3JDb25maWdWYWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdmFsaWRhdG9yQ29uZmlnVmFsdWUgYXMgRHluYW1pY1ZhbGlkYXRvckRlc2NyaXB0b3I7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsaWRhdG9yRm4oZGVzY3JpcHRvci5uYW1lLCBkZXNjcmlwdG9yLmFyZ3MsIHZhbGlkYXRvcnNUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsaWRhdG9yRm4odmFsaWRhdG9yQ29uZmlnS2V5LCB2YWxpZGF0b3JDb25maWdWYWx1ZSwgdmFsaWRhdG9yc1Rva2VuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvckZucztcbiAgICB9XG5cbiAgICBnZXRWYWxpZGF0b3IodmFsaWRhdG9yTmFtZTogc3RyaW5nLCB2YWxpZGF0b3JBcmdzOiBhbnkgPSBudWxsKTogVmFsaWRhdG9yRm4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWxpZGF0b3JGbih2YWxpZGF0b3JOYW1lLCB2YWxpZGF0b3JBcmdzKSBhcyBWYWxpZGF0b3JGbjtcbiAgICB9XG5cbiAgICBnZXRBc3luY1ZhbGlkYXRvcih2YWxpZGF0b3JOYW1lOiBzdHJpbmcsIHZhbGlkYXRvckFyZ3M6IGFueSA9IG51bGwpOiBBc3luY1ZhbGlkYXRvckZuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsaWRhdG9yRm4odmFsaWRhdG9yTmFtZSwgdmFsaWRhdG9yQXJncywgdGhpcy5fTkdfQVNZTkNfVkFMSURBVE9SUykgYXMgQXN5bmNWYWxpZGF0b3JGbjtcbiAgICB9XG5cbiAgICBnZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnNDb25maWc6IER5bmFtaWNWYWxpZGF0b3JzQ29uZmlnKTogVmFsaWRhdG9yRm5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbGlkYXRvckZucyh2YWxpZGF0b3JzQ29uZmlnKSBhcyBWYWxpZGF0b3JGbltdO1xuICAgIH1cblxuICAgIGdldEFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcnNDb25maWc6IER5bmFtaWNWYWxpZGF0b3JzQ29uZmlnKTogQXN5bmNWYWxpZGF0b3JGbltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsaWRhdG9yRm5zKGFzeW5jVmFsaWRhdG9yc0NvbmZpZywgdGhpcy5fTkdfQVNZTkNfVkFMSURBVE9SUykgYXMgQXN5bmNWYWxpZGF0b3JGbltdO1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbGlkYXRvcnModmFsaWRhdG9yc0NvbmZpZzogRHluYW1pY1ZhbGlkYXRvcnNDb25maWcgfCBudWxsLCBjb250cm9sOiBBYnN0cmFjdENvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgICBtb2RlbDogRHluYW1pY0Zvcm1Db250cm9sTW9kZWwpOiB2b2lkIHtcblxuICAgICAgICBtb2RlbC52YWxpZGF0b3JzID0gdmFsaWRhdG9yc0NvbmZpZztcblxuICAgICAgICBpZiAodmFsaWRhdG9yc0NvbmZpZyA9PT0gbnVsbCkge1xuXG4gICAgICAgICAgICBjb250cm9sLmNsZWFyVmFsaWRhdG9ycygpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sLnNldFZhbGlkYXRvcnModGhpcy5nZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnNDb25maWcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZUFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcnNDb25maWc6IER5bmFtaWNWYWxpZGF0b3JzQ29uZmlnIHwgbnVsbCwgY29udHJvbDogQWJzdHJhY3RDb250cm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogRHluYW1pY0Zvcm1Db250cm9sTW9kZWwpOiB2b2lkIHtcblxuICAgICAgICBtb2RlbC5hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnNDb25maWc7XG5cbiAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yc0NvbmZpZyA9PT0gbnVsbCkge1xuXG4gICAgICAgICAgICBjb250cm9sLmNsZWFyQXN5bmNWYWxpZGF0b3JzKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKHRoaXMuZ2V0QXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yc0NvbmZpZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgfVxuXG4gICAgc2hvd0Vycm9yTWVzc2FnZXMoY29udHJvbDogQWJzdHJhY3RDb250cm9sLCBtb2RlbDogRHluYW1pY0Zvcm1Db250cm9sTW9kZWwsIGhhc0ZvY3VzOiBib29sZWFuKTogYm9vbGVhbiB7XG5cbiAgICAgICAgY29uc3QgcHJlY29uZGl0aW9uID0gY29udHJvbC5pbnZhbGlkICYmIG1vZGVsLmhhc0Vycm9yTWVzc2FnZXM7XG4gICAgICAgIGNvbnN0IG1hdGNoZXIgPSB0aGlzLl9EWU5BTUlDX0VSUk9SX01FU1NBR0VTX01BVENIRVIgPyB0aGlzLl9EWU5BTUlDX0VSUk9SX01FU1NBR0VTX01BVENIRVIoY29udHJvbCwgbW9kZWwsIGhhc0ZvY3VzKSA6XG4gICAgICAgICAgICBERUZBVUxUX0VSUk9SX1NUQVRFX01BVENIRVIoY29udHJvbCwgbW9kZWwsIGhhc0ZvY3VzKTtcblxuICAgICAgICByZXR1cm4gcHJlY29uZGl0aW9uICYmIG1hdGNoZXI7XG4gICAgfVxuXG4gICAgcGFyc2VFcnJvck1lc3NhZ2VDb25maWcodGVtcGxhdGU6IHN0cmluZywgbW9kZWw6IER5bmFtaWNGb3JtQ29udHJvbE1vZGVsLCBlcnJvcjogYW55ID0gbnVsbCk6IHN0cmluZyB7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL3t7XFxzKiguKz8pXFxzKn19L21nLCAoX21hdGNoOiBzdHJpbmcsIGV4cHJlc3Npb246IHN0cmluZykgPT4ge1xuXG4gICAgICAgICAgICBsZXQgcHJvcGVydHlTb3VyY2U6IGFueSA9IG1vZGVsO1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5TmFtZTogc3RyaW5nID0gZXhwcmVzc2lvbjtcblxuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaW5kZXhPZihcInZhbGlkYXRvci5cIikgPj0gMCAmJiBlcnJvcikge1xuXG4gICAgICAgICAgICAgICAgcHJvcGVydHlTb3VyY2UgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBleHByZXNzaW9uLnJlcGxhY2UoXCJ2YWxpZGF0b3IuXCIsIFwiXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlTb3VyY2VbcHJvcGVydHlOYW1lXSAhPT0gbnVsbCAmJiBwcm9wZXJ0eVNvdXJjZVtwcm9wZXJ0eU5hbWVdICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHByb3BlcnR5U291cmNlW3Byb3BlcnR5TmFtZV0gOiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjcmVhdGVFcnJvck1lc3NhZ2VzKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCwgbW9kZWw6IER5bmFtaWNGb3JtQ29udHJvbE1vZGVsKTogc3RyaW5nW10ge1xuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIGlmIChtb2RlbC5oYXNFcnJvck1lc3NhZ2VzKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzQ29uZmlnID0gbW9kZWwuZXJyb3JNZXNzYWdlcyBhcyBEeW5hbWljVmFsaWRhdG9yc0NvbmZpZztcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udHJvbC5lcnJvcnMgfHwge30pLmZvckVhY2godmFsaWRhdGlvbkVycm9yS2V5ID0+IHtcblxuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlS2V5ID0gdmFsaWRhdGlvbkVycm9yS2V5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcktleSA9PT0gXCJtaW5sZW5ndGhcIiB8fCB2YWxpZGF0aW9uRXJyb3JLZXkgPT09IFwibWF4bGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUtleSA9IG1lc3NhZ2VLZXkucmVwbGFjZShcImxlbmd0aFwiLCBcIkxlbmd0aFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNDb25maWcuaGFzT3duUHJvcGVydHkobWVzc2FnZUtleSkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBjb250cm9sLmdldEVycm9yKHZhbGlkYXRpb25FcnJvcktleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUZW1wbGF0ZSA9IG1lc3NhZ2VzQ29uZmlnW21lc3NhZ2VLZXldIGFzIHN0cmluZztcblxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHRoaXMucGFyc2VFcnJvck1lc3NhZ2VDb25maWcobWVzc2FnZVRlbXBsYXRlLCBtb2RlbCwgdmFsaWRhdGlvbkVycm9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfVxuXG4gICAgaXNGb3JtSG9vayh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgKE9iamVjdC52YWx1ZXMoRHluYW1pY0Zvcm1Ib29rKSBhcyBzdHJpbmdbXSkuaW5jbHVkZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlzVmFsaWRhdG9yRGVzY3JpcHRvcih2YWx1ZTogYW55KTogYm9vbGVhbiB7XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShcImFyZ3NcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIl19